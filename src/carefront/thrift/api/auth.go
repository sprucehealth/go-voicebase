// This file is automatically generated. Do not modify.

package api

import (
	"fmt"
)

var _ = fmt.Printf

type AuthResponse struct {
	Token     string `thrift:"1,required" json:"token"`
	AccountId int64  `thrift:"2,required" json:"account_id"`
}

type TokenValidationResponse struct {
	IsValid   bool   `thrift:"1,required" json:"is_valid"`
	AccountId *int64 `thrift:"2" json:"account_id,omitempty"`
	Reason    string `thrift:"3" json:"reason,omitempty"`
}

type InvalidPassword struct {
	AccountId int64 `thrift:"1,required" json:"account_id"`
}

func (e *InvalidPassword) Error() string {
	return fmt.Sprintf("InvalidPassword{AccountId: %+v}", e.AccountId)
}

type LoginAlreadyExists struct {
	AccountId int64 `thrift:"1,required" json:"account_id"`
}

func (e *LoginAlreadyExists) Error() string {
	return fmt.Sprintf("LoginAlreadyExists{AccountId: %+v}", e.AccountId)
}

type NoSuchAccount struct {
}

func (e *NoSuchAccount) Error() string {
	return "NoSuchAccount{}"
}

type NoSuchLogin struct {
}

func (e *NoSuchLogin) Error() string {
	return "NoSuchLogin{}"
}

type InvalidRoleType struct {
}

func (e *InvalidRoleType) Error() string {
	return "InvalidRoleType{}"
}

type Auth interface {
	LogIn(login string, password string) (*AuthResponse, error)
	LogOut(token string) error
	SetPassword(accountId int64, password string) error
	SignUp(login string, password string, roleType string) (*AuthResponse, error)
	ValidateToken(token string) (*TokenValidationResponse, error)
	UpdateLastOpenedDate(accountId int64) error
}

type AuthServer struct {
	Implementation Auth
}

func (s *AuthServer) LogIn(req *AuthLogInRequest, res *AuthLogInResponse) error {
	val, err := s.Implementation.LogIn(req.Login, req.Password)
	switch e := err.(type) {
	case *InternalServerError:
		res.Error = e
		err = nil
	case *AccessDenied:
		res.AccessDenied = e
		err = nil
	case *OverCapacity:
		res.OverCapacity = e
		err = nil
	case *NoSuchLogin:
		res.NoSuchLogin = e
		err = nil
	case *InvalidPassword:
		res.InvalidPassword = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *AuthServer) LogOut(req *AuthLogOutRequest, res *AuthLogOutResponse) error {
	err := s.Implementation.LogOut(req.Token)
	switch e := err.(type) {
	case *InternalServerError:
		res.Error = e
		err = nil
	case *AccessDenied:
		res.AccessDenied = e
		err = nil
	case *OverCapacity:
		res.OverCapacity = e
		err = nil
	}
	return err
}

func (s *AuthServer) SetPassword(req *AuthSetPasswordRequest, res *AuthSetPasswordResponse) error {
	err := s.Implementation.SetPassword(req.AccountId, req.Password)
	switch e := err.(type) {
	case *InternalServerError:
		res.Error = e
		err = nil
	case *AccessDenied:
		res.AccessDenied = e
		err = nil
	case *OverCapacity:
		res.OverCapacity = e
		err = nil
	case *NoSuchAccount:
		res.NoSuchAccount = e
		err = nil
	case *InvalidPassword:
		res.InvalidPassword = e
		err = nil
	}
	return err
}

func (s *AuthServer) SignUp(req *AuthSignUpRequest, res *AuthSignUpResponse) error {
	val, err := s.Implementation.SignUp(req.Login, req.Password, req.RoleType)
	switch e := err.(type) {
	case *InternalServerError:
		res.Error = e
		err = nil
	case *AccessDenied:
		res.AccessDenied = e
		err = nil
	case *OverCapacity:
		res.OverCapacity = e
		err = nil
	case *LoginAlreadyExists:
		res.AlreadyExists = e
		err = nil
	case *InvalidPassword:
		res.InvalidPassword = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *AuthServer) ValidateToken(req *AuthValidateTokenRequest, res *AuthValidateTokenResponse) error {
	val, err := s.Implementation.ValidateToken(req.Token)
	switch e := err.(type) {
	case *InternalServerError:
		res.Error = e
		err = nil
	case *AccessDenied:
		res.AccessDenied = e
		err = nil
	case *OverCapacity:
		res.OverCapacity = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *AuthServer) UpdateLastOpenedDate(req *UpdateLastOpenedDateRequest, res *UpdateLastOpenedDateResponse) error {

	err := s.Implementation.UpdateLastOpenedDate(req.AccountId)
	switch e := err.(type) {
	case *InternalServerError:
		res.Error = e
		err = nil
	case *NoSuchAccount:
		res.NoSuchAccount = e
		err = nil
	case *OverCapacity:
		res.OverCapacity = e
		err = nil
	}
	return err
}

type AuthLogInRequest struct {
	Login    string `thrift:"1,required" json:"login"`
	Password string `thrift:"2,required" json:"password"`
}

type AuthLogInResponse struct {
	Value           *AuthResponse        `thrift:"0" json:"value,omitempty"`
	Error           *InternalServerError `thrift:"1" json:"error,omitempty"`
	AccessDenied    *AccessDenied        `thrift:"2" json:"access_denied,omitempty"`
	OverCapacity    *OverCapacity        `thrift:"3" json:"over_capacity,omitempty"`
	NoSuchLogin     *NoSuchLogin         `thrift:"4" json:"no_such_login,omitempty"`
	InvalidPassword *InvalidPassword     `thrift:"5" json:"invalid_password,omitempty"`
}

type AuthLogOutRequest struct {
	Token string `thrift:"1,required" json:"token"`
}

type AuthLogOutResponse struct {
	Error        *InternalServerError `thrift:"1" json:"error,omitempty"`
	AccessDenied *AccessDenied        `thrift:"2" json:"access_denied,omitempty"`
	OverCapacity *OverCapacity        `thrift:"3" json:"over_capacity,omitempty"`
}

type AuthSetPasswordRequest struct {
	AccountId int64  `thrift:"1,required" json:"account_id"`
	Password  string `thrift:"2,required" json:"password"`
}

type AuthSetPasswordResponse struct {
	Error           *InternalServerError `thrift:"1" json:"error,omitempty"`
	AccessDenied    *AccessDenied        `thrift:"2" json:"access_denied,omitempty"`
	OverCapacity    *OverCapacity        `thrift:"3" json:"over_capacity,omitempty"`
	NoSuchAccount   *NoSuchAccount       `thrift:"4" json:"no_such_account,omitempty"`
	InvalidPassword *InvalidPassword     `thrift:"5" json:"invalid_password,omitempty"`
}

type AuthSignUpRequest struct {
	Login    string `thrift:"1,required" json:"login"`
	Password string `thrift:"2,required" json:"password"`
	RoleType string `thrift:"3,required" json:"role_type"`
}

type AuthSignUpResponse struct {
	Value           *AuthResponse        `thrift:"0" json:"value,omitempty"`
	Error           *InternalServerError `thrift:"1" json:"error,omitempty"`
	AccessDenied    *AccessDenied        `thrift:"2" json:"access_denied,omitempty"`
	OverCapacity    *OverCapacity        `thrift:"3" json:"over_capacity,omitempty"`
	AlreadyExists   *LoginAlreadyExists  `thrift:"4" json:"already_exists,omitempty"`
	InvalidPassword *InvalidPassword     `thrift:"5" json:"invalid_password,omitempty"`
	InvalidRoleType *InvalidRoleType     `thrift:"6" json:"invalid_role_type,omitempty"`
}

type AuthValidateTokenRequest struct {
	Token string `thrift:"1,required" json:"token"`
}

type AuthValidateTokenResponse struct {
	Value        *TokenValidationResponse `thrift:"0" json:"value,omitempty"`
	Error        *InternalServerError     `thrift:"1" json:"error,omitempty"`
	AccessDenied *AccessDenied            `thrift:"2" json:"access_denied,omitempty"`
	OverCapacity *OverCapacity            `thrift:"3" json:"over_capacity,omitempty"`
}

type UpdateLastOpenedDateRequest struct {
	AccountId int64 `thrift:"2,required" json:"token"`
}

type UpdateLastOpenedDateResponse struct {
	Error         *InternalServerError `thrift:"1" json:"error,omitempty"`
	NoSuchAccount *NoSuchAccount       `thrift:"2" json:"access_denied,omitempty"`
	OverCapacity  *OverCapacity        `thrift:"3" json:"over_capacity,omitempty"`
}

type AuthClient struct {
	Client RPCClient
}

func (s *AuthClient) LogIn(login string, password string) (ret *AuthResponse, err error) {
	req := &AuthLogInRequest{
		Login:    login,
		Password: password,
	}
	res := &AuthLogInResponse{}
	err = s.Client.Call("log_in", req, res)
	if err == nil {
		switch {
		case res.Error != nil:
			err = res.Error
		case res.AccessDenied != nil:
			err = res.AccessDenied
		case res.OverCapacity != nil:
			err = res.OverCapacity
		case res.NoSuchLogin != nil:
			err = res.NoSuchLogin
		case res.InvalidPassword != nil:
			err = res.InvalidPassword
		}
	}
	if err == nil {
		ret = res.Value
	}
	return
}

func (s *AuthClient) LogOut(token string) (err error) {
	req := &AuthLogOutRequest{
		Token: token,
	}
	res := &AuthLogOutResponse{}
	err = s.Client.Call("log_out", req, res)
	if err == nil {
		switch {
		case res.Error != nil:
			err = res.Error
		case res.AccessDenied != nil:
			err = res.AccessDenied
		case res.OverCapacity != nil:
			err = res.OverCapacity
		}
	}
	return
}

func (s *AuthClient) SetPassword(accountId int64, password string) (err error) {
	req := &AuthSetPasswordRequest{
		AccountId: accountId,
		Password:  password,
	}
	res := &AuthSetPasswordResponse{}
	err = s.Client.Call("set_password", req, res)
	if err == nil {
		switch {
		case res.Error != nil:
			err = res.Error
		case res.AccessDenied != nil:
			err = res.AccessDenied
		case res.OverCapacity != nil:
			err = res.OverCapacity
		case res.NoSuchAccount != nil:
			err = res.NoSuchAccount
		case res.InvalidPassword != nil:
			err = res.InvalidPassword
		}
	}
	return
}

func (s *AuthClient) SignUp(login string, password string, roleType string) (ret *AuthResponse, err error) {
	req := &AuthSignUpRequest{
		Login:    login,
		Password: password,
		RoleType: roleType,
	}
	res := &AuthSignUpResponse{}
	err = s.Client.Call("sign_up", req, res)
	if err == nil {
		switch {
		case res.Error != nil:
			err = res.Error
		case res.AccessDenied != nil:
			err = res.AccessDenied
		case res.OverCapacity != nil:
			err = res.OverCapacity
		case res.AlreadyExists != nil:
			err = res.AlreadyExists
		case res.InvalidPassword != nil:
			err = res.InvalidPassword
		}
	}
	if err == nil {
		ret = res.Value
	}
	return
}

func (s *AuthClient) ValidateToken(token string) (ret *TokenValidationResponse, err error) {
	req := &AuthValidateTokenRequest{
		Token: token,
	}
	res := &AuthValidateTokenResponse{}
	err = s.Client.Call("validate_token", req, res)
	if err == nil {
		switch {
		case res.Error != nil:
			err = res.Error
		case res.AccessDenied != nil:
			err = res.AccessDenied
		case res.OverCapacity != nil:
			err = res.OverCapacity
		}
	}
	if err == nil {
		ret = res.Value
	}
	return
}

func (s *AuthClient) UpdateLastOpenedDate(accountId int64) error {
	req := &UpdateLastOpenedDateRequest{
		AccountId: accountId,
	}
	res := &UpdateLastOpenedDateResponse{}
	err := s.Client.Call("update_last_opened_date", req, res)
	if err == nil {
		switch {
		case res.Error != nil:
			err = res.Error
		case res.NoSuchAccount != nil:
			err = res.NoSuchAccount
		case res.OverCapacity != nil:
			err = res.OverCapacity
		}
	}

	return nil
}
