// Code generated by protoc-gen-gogo.
// source: svc.proto
// DO NOT EDIT!

/*
Package routing is a generated protocol buffer package.

It is generated from these files:
	svc.proto

It has these top-level messages:
	Message
	VoicemailAttachment
	RouteMessageRequest
	RouteMessageResponse
*/
package routing

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// ChannelType specifies the channel over which the communication
// is intended to take place.
type ChannelType int32

const (
	ChannelType_Voice ChannelType = 0
	ChannelType_SMS   ChannelType = 1
)

var ChannelType_name = map[int32]string{
	0: "Voice",
	1: "SMS",
}
var ChannelType_value = map[string]int32{
	"Voice": 0,
	"SMS":   1,
}

func (x ChannelType) String() string {
	return proto.EnumName(ChannelType_name, int32(x))
}

type Message_Attachment_Type int32

const (
	Message_Attachment_Voicemail Message_Attachment_Type = 0
)

var Message_Attachment_Type_name = map[int32]string{
	0: "Voicemail",
}
var Message_Attachment_Type_value = map[string]int32{
	"Voicemail": 0,
}

func (x Message_Attachment_Type) String() string {
	return proto.EnumName(Message_Attachment_Type_name, int32(x))
}

// Message represents a generic message that contains text and a list of attachments
// to be delivered over a certain external channel. It is not necessary for the destination
// to be specified in which case the routing service determines the best way to deliver the message.
type Message struct {
	Text        string                `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	Attachments []*Message_Attachment `protobuf:"bytes,2,rep,name=attachments" json:"attachments,omitempty"`
	Created     uint64                `protobuf:"varint,3,opt,name=created,proto3" json:"created,omitempty"`
	// from_entity_id and to_entity_id represent the addressable id of the source retrieved
	// from the directory service.
	FromEntityId string `protobuf:"bytes,4,opt,name=from_entity_id,proto3" json:"from_entity_id,omitempty"`
	ToEntityId   string `protobuf:"bytes,5,opt,name=to_entity_id,proto3" json:"to_entity_id,omitempty"`
	// from_channel_id and to_channel_id represent the id of the source
	// and destination specific to the channel.
	Channel       ChannelType `protobuf:"varint,6,opt,name=channel,proto3,enum=routing.ChannelType" json:"channel,omitempty"`
	FromChannelId string      `protobuf:"bytes,7,opt,name=from_channel_id,proto3" json:"from_channel_id,omitempty"`
	ToChannelId   string      `protobuf:"bytes,8,opt,name=to_channel_id,proto3" json:"to_channel_id,omitempty"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}

func (m *Message) GetAttachments() []*Message_Attachment {
	if m != nil {
		return m.Attachments
	}
	return nil
}

// AttachmentData is a typed representation of attachment data.
type Message_Attachment struct {
	Type Message_Attachment_Type `protobuf:"varint,1,opt,name=type,proto3,enum=routing.Message_Attachment_Type" json:"type,omitempty"`
	// Types that are valid to be assigned to Attachments:
	//	*Message_Attachment_AttachmentVoicemail
	Attachments isMessage_Attachment_Attachments `protobuf_oneof:"attachments"`
}

func (m *Message_Attachment) Reset()         { *m = Message_Attachment{} }
func (m *Message_Attachment) String() string { return proto.CompactTextString(m) }
func (*Message_Attachment) ProtoMessage()    {}

type isMessage_Attachment_Attachments interface {
	isMessage_Attachment_Attachments()
}

type Message_Attachment_AttachmentVoicemail struct {
	AttachmentVoicemail *VoicemailAttachment `protobuf:"bytes,2,opt,name=attachment_voicemail,oneof"`
}

func (*Message_Attachment_AttachmentVoicemail) isMessage_Attachment_Attachments() {}

func (m *Message_Attachment) GetAttachments() isMessage_Attachment_Attachments {
	if m != nil {
		return m.Attachments
	}
	return nil
}

func (m *Message_Attachment) GetAttachmentVoicemail() *VoicemailAttachment {
	if x, ok := m.GetAttachments().(*Message_Attachment_AttachmentVoicemail); ok {
		return x.AttachmentVoicemail
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Message_Attachment) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _Message_Attachment_OneofMarshaler, _Message_Attachment_OneofUnmarshaler, []interface{}{
		(*Message_Attachment_AttachmentVoicemail)(nil),
	}
}

func _Message_Attachment_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Message_Attachment)
	// attachments
	switch x := m.Attachments.(type) {
	case *Message_Attachment_AttachmentVoicemail:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AttachmentVoicemail); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Message_Attachment.Attachments has unexpected type %T", x)
	}
	return nil
}

func _Message_Attachment_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Message_Attachment)
	switch tag {
	case 2: // attachments.attachment_voicemail
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VoicemailAttachment)
		err := b.DecodeMessage(msg)
		m.Attachments = &Message_Attachment_AttachmentVoicemail{msg}
		return true, err
	default:
		return false, nil
	}
}

// VoicemailAttachment represents a voicemail attachment.
type VoicemailAttachment struct {
	DurationInSeconds uint32 `protobuf:"varint,1,opt,name=duration_in_seconds,proto3" json:"duration_in_seconds,omitempty"`
	Url               string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *VoicemailAttachment) Reset()         { *m = VoicemailAttachment{} }
func (m *VoicemailAttachment) String() string { return proto.CompactTextString(m) }
func (*VoicemailAttachment) ProtoMessage()    {}

type RouteMessageRequest struct {
	Message *Message `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
}

func (m *RouteMessageRequest) Reset()         { *m = RouteMessageRequest{} }
func (m *RouteMessageRequest) String() string { return proto.CompactTextString(m) }
func (*RouteMessageRequest) ProtoMessage()    {}

func (m *RouteMessageRequest) GetMessage() *Message {
	if m != nil {
		return m.Message
	}
	return nil
}

type RouteMessageResponse struct {
}

func (m *RouteMessageResponse) Reset()         { *m = RouteMessageResponse{} }
func (m *RouteMessageResponse) String() string { return proto.CompactTextString(m) }
func (*RouteMessageResponse) ProtoMessage()    {}

func init() {
	proto.RegisterType((*Message)(nil), "routing.Message")
	proto.RegisterType((*Message_Attachment)(nil), "routing.Message.Attachment")
	proto.RegisterType((*VoicemailAttachment)(nil), "routing.VoicemailAttachment")
	proto.RegisterType((*RouteMessageRequest)(nil), "routing.RouteMessageRequest")
	proto.RegisterType((*RouteMessageResponse)(nil), "routing.RouteMessageResponse")
	proto.RegisterEnum("routing.ChannelType", ChannelType_name, ChannelType_value)
	proto.RegisterEnum("routing.Message_Attachment_Type", Message_Attachment_Type_name, Message_Attachment_Type_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Routing service

type RoutingClient interface {
	RouteMessage(ctx context.Context, in *RouteMessageRequest, opts ...grpc.CallOption) (*RouteMessageResponse, error)
}

type routingClient struct {
	cc *grpc.ClientConn
}

func NewRoutingClient(cc *grpc.ClientConn) RoutingClient {
	return &routingClient{cc}
}

func (c *routingClient) RouteMessage(ctx context.Context, in *RouteMessageRequest, opts ...grpc.CallOption) (*RouteMessageResponse, error) {
	out := new(RouteMessageResponse)
	err := grpc.Invoke(ctx, "/routing.Routing/RouteMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Routing service

type RoutingServer interface {
	RouteMessage(context.Context, *RouteMessageRequest) (*RouteMessageResponse, error)
}

func RegisterRoutingServer(s *grpc.Server, srv RoutingServer) {
	s.RegisterService(&_Routing_serviceDesc, srv)
}

func _Routing_RouteMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RouteMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RoutingServer).RouteMessage(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Routing_serviceDesc = grpc.ServiceDesc{
	ServiceName: "routing.Routing",
	HandlerType: (*RoutingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RouteMessage",
			Handler:    _Routing_RouteMessage_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
