// Code generated by protoc-gen-gogo.
// source: gen.proto
// DO NOT EDIT!

/*
	Package models is a generated protocol buffer package.

	It is generated from these files:
		gen.proto

	It has these top-level messages:
		Answer
		FreeTextAnswer
		MultipleChoiceAnswer
		SingleSelectAnswer
		SegmentedControlAnswer
		SingleEntryAnswer
		AnswerOption
		AutocompleteAnswerItem
		AutocompleteAnswer
		MediaSectionAnswer
*/
package models

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import strconv "strconv"

import strings "strings"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
import sort "sort"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import errors "errors"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion1

// MediaType represents the type of media for an object.
type MediaType int32

const (
	MediaType_MEDIA_TYPE_UNKNOWN MediaType = 0
	MediaType_IMAGE              MediaType = 1
	MediaType_VIDEO              MediaType = 2
)

var MediaType_name = map[int32]string{
	0: "MEDIA_TYPE_UNKNOWN",
	1: "IMAGE",
	2: "VIDEO",
}
var MediaType_value = map[string]int32{
	"MEDIA_TYPE_UNKNOWN": 0,
	"IMAGE":              1,
	"VIDEO":              2,
}

func (MediaType) EnumDescriptor() ([]byte, []int) { return fileDescriptorGen, []int{0} }

type Answer struct {
	QuestionID string `protobuf:"bytes,1,opt,name=question_id,proto3" json:"question_id,omitempty"`
	Type       string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// Types that are valid to be assigned to Answer:
	//	*Answer_FreeText
	//	*Answer_MultipleChoice
	//	*Answer_SingleSelect
	//	*Answer_Autocomplete
	//	*Answer_MediaSection
	//	*Answer_SingleEntry
	//	*Answer_SegmentedControl
	Answer isAnswer_Answer `protobuf_oneof:"answer"`
}

func (m *Answer) Reset()                    { *m = Answer{} }
func (*Answer) ProtoMessage()               {}
func (*Answer) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{0} }

type isAnswer_Answer interface {
	isAnswer_Answer()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Answer_FreeText struct {
	FreeText *FreeTextAnswer `protobuf:"bytes,10,opt,name=free_text,oneof"`
}
type Answer_MultipleChoice struct {
	MultipleChoice *MultipleChoiceAnswer `protobuf:"bytes,11,opt,name=multiple_choice,oneof"`
}
type Answer_SingleSelect struct {
	SingleSelect *SingleSelectAnswer `protobuf:"bytes,12,opt,name=single_select,oneof"`
}
type Answer_Autocomplete struct {
	Autocomplete *AutocompleteAnswer `protobuf:"bytes,13,opt,name=autocomplete,oneof"`
}
type Answer_MediaSection struct {
	MediaSection *MediaSectionAnswer `protobuf:"bytes,14,opt,name=media_section,oneof"`
}
type Answer_SingleEntry struct {
	SingleEntry *SingleEntryAnswer `protobuf:"bytes,15,opt,name=single_entry,oneof"`
}
type Answer_SegmentedControl struct {
	SegmentedControl *SegmentedControlAnswer `protobuf:"bytes,16,opt,name=segmented_control,oneof"`
}

func (*Answer_FreeText) isAnswer_Answer()         {}
func (*Answer_MultipleChoice) isAnswer_Answer()   {}
func (*Answer_SingleSelect) isAnswer_Answer()     {}
func (*Answer_Autocomplete) isAnswer_Answer()     {}
func (*Answer_MediaSection) isAnswer_Answer()     {}
func (*Answer_SingleEntry) isAnswer_Answer()      {}
func (*Answer_SegmentedControl) isAnswer_Answer() {}

func (m *Answer) GetAnswer() isAnswer_Answer {
	if m != nil {
		return m.Answer
	}
	return nil
}

func (m *Answer) GetFreeText() *FreeTextAnswer {
	if x, ok := m.GetAnswer().(*Answer_FreeText); ok {
		return x.FreeText
	}
	return nil
}

func (m *Answer) GetMultipleChoice() *MultipleChoiceAnswer {
	if x, ok := m.GetAnswer().(*Answer_MultipleChoice); ok {
		return x.MultipleChoice
	}
	return nil
}

func (m *Answer) GetSingleSelect() *SingleSelectAnswer {
	if x, ok := m.GetAnswer().(*Answer_SingleSelect); ok {
		return x.SingleSelect
	}
	return nil
}

func (m *Answer) GetAutocomplete() *AutocompleteAnswer {
	if x, ok := m.GetAnswer().(*Answer_Autocomplete); ok {
		return x.Autocomplete
	}
	return nil
}

func (m *Answer) GetMediaSection() *MediaSectionAnswer {
	if x, ok := m.GetAnswer().(*Answer_MediaSection); ok {
		return x.MediaSection
	}
	return nil
}

func (m *Answer) GetSingleEntry() *SingleEntryAnswer {
	if x, ok := m.GetAnswer().(*Answer_SingleEntry); ok {
		return x.SingleEntry
	}
	return nil
}

func (m *Answer) GetSegmentedControl() *SegmentedControlAnswer {
	if x, ok := m.GetAnswer().(*Answer_SegmentedControl); ok {
		return x.SegmentedControl
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Answer) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Answer_OneofMarshaler, _Answer_OneofUnmarshaler, _Answer_OneofSizer, []interface{}{
		(*Answer_FreeText)(nil),
		(*Answer_MultipleChoice)(nil),
		(*Answer_SingleSelect)(nil),
		(*Answer_Autocomplete)(nil),
		(*Answer_MediaSection)(nil),
		(*Answer_SingleEntry)(nil),
		(*Answer_SegmentedControl)(nil),
	}
}

func _Answer_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Answer)
	// answer
	switch x := m.Answer.(type) {
	case *Answer_FreeText:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FreeText); err != nil {
			return err
		}
	case *Answer_MultipleChoice:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MultipleChoice); err != nil {
			return err
		}
	case *Answer_SingleSelect:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SingleSelect); err != nil {
			return err
		}
	case *Answer_Autocomplete:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Autocomplete); err != nil {
			return err
		}
	case *Answer_MediaSection:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MediaSection); err != nil {
			return err
		}
	case *Answer_SingleEntry:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SingleEntry); err != nil {
			return err
		}
	case *Answer_SegmentedControl:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SegmentedControl); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Answer.Answer has unexpected type %T", x)
	}
	return nil
}

func _Answer_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Answer)
	switch tag {
	case 10: // answer.free_text
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FreeTextAnswer)
		err := b.DecodeMessage(msg)
		m.Answer = &Answer_FreeText{msg}
		return true, err
	case 11: // answer.multiple_choice
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MultipleChoiceAnswer)
		err := b.DecodeMessage(msg)
		m.Answer = &Answer_MultipleChoice{msg}
		return true, err
	case 12: // answer.single_select
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SingleSelectAnswer)
		err := b.DecodeMessage(msg)
		m.Answer = &Answer_SingleSelect{msg}
		return true, err
	case 13: // answer.autocomplete
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AutocompleteAnswer)
		err := b.DecodeMessage(msg)
		m.Answer = &Answer_Autocomplete{msg}
		return true, err
	case 14: // answer.media_section
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MediaSectionAnswer)
		err := b.DecodeMessage(msg)
		m.Answer = &Answer_MediaSection{msg}
		return true, err
	case 15: // answer.single_entry
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SingleEntryAnswer)
		err := b.DecodeMessage(msg)
		m.Answer = &Answer_SingleEntry{msg}
		return true, err
	case 16: // answer.segmented_control
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SegmentedControlAnswer)
		err := b.DecodeMessage(msg)
		m.Answer = &Answer_SegmentedControl{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Answer_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Answer)
	// answer
	switch x := m.Answer.(type) {
	case *Answer_FreeText:
		s := proto.Size(x.FreeText)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Answer_MultipleChoice:
		s := proto.Size(x.MultipleChoice)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Answer_SingleSelect:
		s := proto.Size(x.SingleSelect)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Answer_Autocomplete:
		s := proto.Size(x.Autocomplete)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Answer_MediaSection:
		s := proto.Size(x.MediaSection)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Answer_SingleEntry:
		s := proto.Size(x.SingleEntry)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Answer_SegmentedControl:
		s := proto.Size(x.SegmentedControl)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type FreeTextAnswer struct {
	FreeText string `protobuf:"bytes,1,opt,name=free_text,proto3" json:"free_text,omitempty"`
}

func (m *FreeTextAnswer) Reset()                    { *m = FreeTextAnswer{} }
func (*FreeTextAnswer) ProtoMessage()               {}
func (*FreeTextAnswer) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{1} }

type MultipleChoiceAnswer struct {
	SelectedAnswers []*AnswerOption `protobuf:"bytes,1,rep,name=selected_answers" json:"selected_answers,omitempty"`
}

func (m *MultipleChoiceAnswer) Reset()                    { *m = MultipleChoiceAnswer{} }
func (*MultipleChoiceAnswer) ProtoMessage()               {}
func (*MultipleChoiceAnswer) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{2} }

func (m *MultipleChoiceAnswer) GetSelectedAnswers() []*AnswerOption {
	if m != nil {
		return m.SelectedAnswers
	}
	return nil
}

type SingleSelectAnswer struct {
	SelectedAnswer *AnswerOption `protobuf:"bytes,1,opt,name=selected_answer" json:"selected_answer,omitempty"`
}

func (m *SingleSelectAnswer) Reset()                    { *m = SingleSelectAnswer{} }
func (*SingleSelectAnswer) ProtoMessage()               {}
func (*SingleSelectAnswer) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{3} }

func (m *SingleSelectAnswer) GetSelectedAnswer() *AnswerOption {
	if m != nil {
		return m.SelectedAnswer
	}
	return nil
}

type SegmentedControlAnswer struct {
	SelectedAnswer *AnswerOption `protobuf:"bytes,1,opt,name=selected_answer" json:"selected_answer,omitempty"`
}

func (m *SegmentedControlAnswer) Reset()                    { *m = SegmentedControlAnswer{} }
func (*SegmentedControlAnswer) ProtoMessage()               {}
func (*SegmentedControlAnswer) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{4} }

func (m *SegmentedControlAnswer) GetSelectedAnswer() *AnswerOption {
	if m != nil {
		return m.SelectedAnswer
	}
	return nil
}

type SingleEntryAnswer struct {
	FreeText string `protobuf:"bytes,1,opt,name=free_text,proto3" json:"free_text,omitempty"`
}

func (m *SingleEntryAnswer) Reset()                    { *m = SingleEntryAnswer{} }
func (*SingleEntryAnswer) ProtoMessage()               {}
func (*SingleEntryAnswer) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{5} }

type AnswerOption struct {
	ID         string             `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	FreeText   string             `protobuf:"bytes,2,opt,name=free_text,proto3" json:"free_text,omitempty"`
	SubAnswers map[string]*Answer `protobuf:"bytes,3,rep,name=sub_answers" json:"sub_answers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AnswerOption) Reset()                    { *m = AnswerOption{} }
func (*AnswerOption) ProtoMessage()               {}
func (*AnswerOption) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{6} }

func (m *AnswerOption) GetSubAnswers() map[string]*Answer {
	if m != nil {
		return m.SubAnswers
	}
	return nil
}

type AutocompleteAnswerItem struct {
	Answer     string             `protobuf:"bytes,1,opt,name=answer,proto3" json:"answer,omitempty"`
	SubAnswers map[string]*Answer `protobuf:"bytes,2,rep,name=sub_answers" json:"sub_answers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AutocompleteAnswerItem) Reset()                    { *m = AutocompleteAnswerItem{} }
func (*AutocompleteAnswerItem) ProtoMessage()               {}
func (*AutocompleteAnswerItem) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{7} }

func (m *AutocompleteAnswerItem) GetSubAnswers() map[string]*Answer {
	if m != nil {
		return m.SubAnswers
	}
	return nil
}

type AutocompleteAnswer struct {
	Items []*AutocompleteAnswerItem `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *AutocompleteAnswer) Reset()                    { *m = AutocompleteAnswer{} }
func (*AutocompleteAnswer) ProtoMessage()               {}
func (*AutocompleteAnswer) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{8} }

func (m *AutocompleteAnswer) GetItems() []*AutocompleteAnswerItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type MediaSectionAnswer struct {
	Sections []*MediaSectionAnswer_MediaSectionItem `protobuf:"bytes,1,rep,name=sections" json:"sections,omitempty"`
}

func (m *MediaSectionAnswer) Reset()                    { *m = MediaSectionAnswer{} }
func (*MediaSectionAnswer) ProtoMessage()               {}
func (*MediaSectionAnswer) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{9} }

func (m *MediaSectionAnswer) GetSections() []*MediaSectionAnswer_MediaSectionItem {
	if m != nil {
		return m.Sections
	}
	return nil
}

type MediaSectionAnswer_MediaSectionItem struct {
	Name  string                                               `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Slots []*MediaSectionAnswer_MediaSectionItem_MediaSlotItem `protobuf:"bytes,2,rep,name=slots" json:"slots,omitempty"`
}

func (m *MediaSectionAnswer_MediaSectionItem) Reset()      { *m = MediaSectionAnswer_MediaSectionItem{} }
func (*MediaSectionAnswer_MediaSectionItem) ProtoMessage() {}
func (*MediaSectionAnswer_MediaSectionItem) Descriptor() ([]byte, []int) {
	return fileDescriptorGen, []int{9, 0}
}

func (m *MediaSectionAnswer_MediaSectionItem) GetSlots() []*MediaSectionAnswer_MediaSectionItem_MediaSlotItem {
	if m != nil {
		return m.Slots
	}
	return nil
}

type MediaSectionAnswer_MediaSectionItem_MediaSlotItem struct {
	SlotID  string    `protobuf:"bytes,1,opt,name=slot_id,proto3" json:"slot_id,omitempty"`
	Name    string    `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	MediaID string    `protobuf:"bytes,3,opt,name=media_id,proto3" json:"media_id,omitempty"`
	Type    MediaType `protobuf:"varint,4,opt,name=type,proto3,enum=models.MediaType" json:"type,omitempty"`
}

func (m *MediaSectionAnswer_MediaSectionItem_MediaSlotItem) Reset() {
	*m = MediaSectionAnswer_MediaSectionItem_MediaSlotItem{}
}
func (*MediaSectionAnswer_MediaSectionItem_MediaSlotItem) ProtoMessage() {}
func (*MediaSectionAnswer_MediaSectionItem_MediaSlotItem) Descriptor() ([]byte, []int) {
	return fileDescriptorGen, []int{9, 0, 0}
}

func init() {
	proto.RegisterType((*Answer)(nil), "models.Answer")
	proto.RegisterType((*FreeTextAnswer)(nil), "models.FreeTextAnswer")
	proto.RegisterType((*MultipleChoiceAnswer)(nil), "models.MultipleChoiceAnswer")
	proto.RegisterType((*SingleSelectAnswer)(nil), "models.SingleSelectAnswer")
	proto.RegisterType((*SegmentedControlAnswer)(nil), "models.SegmentedControlAnswer")
	proto.RegisterType((*SingleEntryAnswer)(nil), "models.SingleEntryAnswer")
	proto.RegisterType((*AnswerOption)(nil), "models.AnswerOption")
	proto.RegisterType((*AutocompleteAnswerItem)(nil), "models.AutocompleteAnswerItem")
	proto.RegisterType((*AutocompleteAnswer)(nil), "models.AutocompleteAnswer")
	proto.RegisterType((*MediaSectionAnswer)(nil), "models.MediaSectionAnswer")
	proto.RegisterType((*MediaSectionAnswer_MediaSectionItem)(nil), "models.MediaSectionAnswer.MediaSectionItem")
	proto.RegisterType((*MediaSectionAnswer_MediaSectionItem_MediaSlotItem)(nil), "models.MediaSectionAnswer.MediaSectionItem.MediaSlotItem")
	proto.RegisterEnum("models.MediaType", MediaType_name, MediaType_value)
}
func (x MediaType) String() string {
	s, ok := MediaType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Answer) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Answer)
	if !ok {
		that2, ok := that.(Answer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.QuestionID != that1.QuestionID {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if that1.Answer == nil {
		if this.Answer != nil {
			return false
		}
	} else if this.Answer == nil {
		return false
	} else if !this.Answer.Equal(that1.Answer) {
		return false
	}
	return true
}
func (this *Answer_FreeText) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Answer_FreeText)
	if !ok {
		that2, ok := that.(Answer_FreeText)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.FreeText.Equal(that1.FreeText) {
		return false
	}
	return true
}
func (this *Answer_MultipleChoice) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Answer_MultipleChoice)
	if !ok {
		that2, ok := that.(Answer_MultipleChoice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.MultipleChoice.Equal(that1.MultipleChoice) {
		return false
	}
	return true
}
func (this *Answer_SingleSelect) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Answer_SingleSelect)
	if !ok {
		that2, ok := that.(Answer_SingleSelect)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.SingleSelect.Equal(that1.SingleSelect) {
		return false
	}
	return true
}
func (this *Answer_Autocomplete) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Answer_Autocomplete)
	if !ok {
		that2, ok := that.(Answer_Autocomplete)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Autocomplete.Equal(that1.Autocomplete) {
		return false
	}
	return true
}
func (this *Answer_MediaSection) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Answer_MediaSection)
	if !ok {
		that2, ok := that.(Answer_MediaSection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.MediaSection.Equal(that1.MediaSection) {
		return false
	}
	return true
}
func (this *Answer_SingleEntry) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Answer_SingleEntry)
	if !ok {
		that2, ok := that.(Answer_SingleEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.SingleEntry.Equal(that1.SingleEntry) {
		return false
	}
	return true
}
func (this *Answer_SegmentedControl) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Answer_SegmentedControl)
	if !ok {
		that2, ok := that.(Answer_SegmentedControl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.SegmentedControl.Equal(that1.SegmentedControl) {
		return false
	}
	return true
}
func (this *FreeTextAnswer) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FreeTextAnswer)
	if !ok {
		that2, ok := that.(FreeTextAnswer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.FreeText != that1.FreeText {
		return false
	}
	return true
}
func (this *MultipleChoiceAnswer) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MultipleChoiceAnswer)
	if !ok {
		that2, ok := that.(MultipleChoiceAnswer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.SelectedAnswers) != len(that1.SelectedAnswers) {
		return false
	}
	for i := range this.SelectedAnswers {
		if !this.SelectedAnswers[i].Equal(that1.SelectedAnswers[i]) {
			return false
		}
	}
	return true
}
func (this *SingleSelectAnswer) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SingleSelectAnswer)
	if !ok {
		that2, ok := that.(SingleSelectAnswer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.SelectedAnswer.Equal(that1.SelectedAnswer) {
		return false
	}
	return true
}
func (this *SegmentedControlAnswer) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SegmentedControlAnswer)
	if !ok {
		that2, ok := that.(SegmentedControlAnswer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.SelectedAnswer.Equal(that1.SelectedAnswer) {
		return false
	}
	return true
}
func (this *SingleEntryAnswer) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SingleEntryAnswer)
	if !ok {
		that2, ok := that.(SingleEntryAnswer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.FreeText != that1.FreeText {
		return false
	}
	return true
}
func (this *AnswerOption) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AnswerOption)
	if !ok {
		that2, ok := that.(AnswerOption)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.FreeText != that1.FreeText {
		return false
	}
	if len(this.SubAnswers) != len(that1.SubAnswers) {
		return false
	}
	for i := range this.SubAnswers {
		if !this.SubAnswers[i].Equal(that1.SubAnswers[i]) {
			return false
		}
	}
	return true
}
func (this *AutocompleteAnswerItem) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AutocompleteAnswerItem)
	if !ok {
		that2, ok := that.(AutocompleteAnswerItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Answer != that1.Answer {
		return false
	}
	if len(this.SubAnswers) != len(that1.SubAnswers) {
		return false
	}
	for i := range this.SubAnswers {
		if !this.SubAnswers[i].Equal(that1.SubAnswers[i]) {
			return false
		}
	}
	return true
}
func (this *AutocompleteAnswer) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AutocompleteAnswer)
	if !ok {
		that2, ok := that.(AutocompleteAnswer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *MediaSectionAnswer) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MediaSectionAnswer)
	if !ok {
		that2, ok := that.(MediaSectionAnswer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Sections) != len(that1.Sections) {
		return false
	}
	for i := range this.Sections {
		if !this.Sections[i].Equal(that1.Sections[i]) {
			return false
		}
	}
	return true
}
func (this *MediaSectionAnswer_MediaSectionItem) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MediaSectionAnswer_MediaSectionItem)
	if !ok {
		that2, ok := that.(MediaSectionAnswer_MediaSectionItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Slots) != len(that1.Slots) {
		return false
	}
	for i := range this.Slots {
		if !this.Slots[i].Equal(that1.Slots[i]) {
			return false
		}
	}
	return true
}
func (this *MediaSectionAnswer_MediaSectionItem_MediaSlotItem) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MediaSectionAnswer_MediaSectionItem_MediaSlotItem)
	if !ok {
		that2, ok := that.(MediaSectionAnswer_MediaSectionItem_MediaSlotItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.SlotID != that1.SlotID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.MediaID != that1.MediaID {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *Answer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&models.Answer{")
	s = append(s, "QuestionID: "+fmt.Sprintf("%#v", this.QuestionID)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Answer != nil {
		s = append(s, "Answer: "+fmt.Sprintf("%#v", this.Answer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Answer_FreeText) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&models.Answer_FreeText{` +
		`FreeText:` + fmt.Sprintf("%#v", this.FreeText) + `}`}, ", ")
	return s
}
func (this *Answer_MultipleChoice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&models.Answer_MultipleChoice{` +
		`MultipleChoice:` + fmt.Sprintf("%#v", this.MultipleChoice) + `}`}, ", ")
	return s
}
func (this *Answer_SingleSelect) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&models.Answer_SingleSelect{` +
		`SingleSelect:` + fmt.Sprintf("%#v", this.SingleSelect) + `}`}, ", ")
	return s
}
func (this *Answer_Autocomplete) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&models.Answer_Autocomplete{` +
		`Autocomplete:` + fmt.Sprintf("%#v", this.Autocomplete) + `}`}, ", ")
	return s
}
func (this *Answer_MediaSection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&models.Answer_MediaSection{` +
		`MediaSection:` + fmt.Sprintf("%#v", this.MediaSection) + `}`}, ", ")
	return s
}
func (this *Answer_SingleEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&models.Answer_SingleEntry{` +
		`SingleEntry:` + fmt.Sprintf("%#v", this.SingleEntry) + `}`}, ", ")
	return s
}
func (this *Answer_SegmentedControl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&models.Answer_SegmentedControl{` +
		`SegmentedControl:` + fmt.Sprintf("%#v", this.SegmentedControl) + `}`}, ", ")
	return s
}
func (this *FreeTextAnswer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&models.FreeTextAnswer{")
	s = append(s, "FreeText: "+fmt.Sprintf("%#v", this.FreeText)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MultipleChoiceAnswer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&models.MultipleChoiceAnswer{")
	if this.SelectedAnswers != nil {
		s = append(s, "SelectedAnswers: "+fmt.Sprintf("%#v", this.SelectedAnswers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SingleSelectAnswer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&models.SingleSelectAnswer{")
	if this.SelectedAnswer != nil {
		s = append(s, "SelectedAnswer: "+fmt.Sprintf("%#v", this.SelectedAnswer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SegmentedControlAnswer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&models.SegmentedControlAnswer{")
	if this.SelectedAnswer != nil {
		s = append(s, "SelectedAnswer: "+fmt.Sprintf("%#v", this.SelectedAnswer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SingleEntryAnswer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&models.SingleEntryAnswer{")
	s = append(s, "FreeText: "+fmt.Sprintf("%#v", this.FreeText)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AnswerOption) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&models.AnswerOption{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	s = append(s, "FreeText: "+fmt.Sprintf("%#v", this.FreeText)+",\n")
	keysForSubAnswers := make([]string, 0, len(this.SubAnswers))
	for k, _ := range this.SubAnswers {
		keysForSubAnswers = append(keysForSubAnswers, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSubAnswers)
	mapStringForSubAnswers := "map[string]*Answer{"
	for _, k := range keysForSubAnswers {
		mapStringForSubAnswers += fmt.Sprintf("%#v: %#v,", k, this.SubAnswers[k])
	}
	mapStringForSubAnswers += "}"
	if this.SubAnswers != nil {
		s = append(s, "SubAnswers: "+mapStringForSubAnswers+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AutocompleteAnswerItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&models.AutocompleteAnswerItem{")
	s = append(s, "Answer: "+fmt.Sprintf("%#v", this.Answer)+",\n")
	keysForSubAnswers := make([]string, 0, len(this.SubAnswers))
	for k, _ := range this.SubAnswers {
		keysForSubAnswers = append(keysForSubAnswers, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSubAnswers)
	mapStringForSubAnswers := "map[string]*Answer{"
	for _, k := range keysForSubAnswers {
		mapStringForSubAnswers += fmt.Sprintf("%#v: %#v,", k, this.SubAnswers[k])
	}
	mapStringForSubAnswers += "}"
	if this.SubAnswers != nil {
		s = append(s, "SubAnswers: "+mapStringForSubAnswers+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AutocompleteAnswer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&models.AutocompleteAnswer{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MediaSectionAnswer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&models.MediaSectionAnswer{")
	if this.Sections != nil {
		s = append(s, "Sections: "+fmt.Sprintf("%#v", this.Sections)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MediaSectionAnswer_MediaSectionItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&models.MediaSectionAnswer_MediaSectionItem{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Slots != nil {
		s = append(s, "Slots: "+fmt.Sprintf("%#v", this.Slots)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MediaSectionAnswer_MediaSectionItem_MediaSlotItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&models.MediaSectionAnswer_MediaSectionItem_MediaSlotItem{")
	s = append(s, "SlotID: "+fmt.Sprintf("%#v", this.SlotID)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "MediaID: "+fmt.Sprintf("%#v", this.MediaID)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringGen(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringGen(e map[int32]github_com_gogo_protobuf_proto.Extension) string {
	if e == nil {
		return "nil"
	}
	s := "map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "}"
	return s
}
func (m *Answer) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Answer) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.QuestionID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintGen(data, i, uint64(len(m.QuestionID)))
		i += copy(data[i:], m.QuestionID)
	}
	if len(m.Type) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintGen(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.Answer != nil {
		nn1, err := m.Answer.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *Answer_FreeText) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.FreeText != nil {
		data[i] = 0x52
		i++
		i = encodeVarintGen(data, i, uint64(m.FreeText.Size()))
		n2, err := m.FreeText.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *Answer_MultipleChoice) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.MultipleChoice != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintGen(data, i, uint64(m.MultipleChoice.Size()))
		n3, err := m.MultipleChoice.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *Answer_SingleSelect) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.SingleSelect != nil {
		data[i] = 0x62
		i++
		i = encodeVarintGen(data, i, uint64(m.SingleSelect.Size()))
		n4, err := m.SingleSelect.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *Answer_Autocomplete) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Autocomplete != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintGen(data, i, uint64(m.Autocomplete.Size()))
		n5, err := m.Autocomplete.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *Answer_MediaSection) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.MediaSection != nil {
		data[i] = 0x72
		i++
		i = encodeVarintGen(data, i, uint64(m.MediaSection.Size()))
		n6, err := m.MediaSection.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *Answer_SingleEntry) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.SingleEntry != nil {
		data[i] = 0x7a
		i++
		i = encodeVarintGen(data, i, uint64(m.SingleEntry.Size()))
		n7, err := m.SingleEntry.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *Answer_SegmentedControl) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.SegmentedControl != nil {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintGen(data, i, uint64(m.SegmentedControl.Size()))
		n8, err := m.SegmentedControl.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *FreeTextAnswer) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FreeTextAnswer) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FreeText) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintGen(data, i, uint64(len(m.FreeText)))
		i += copy(data[i:], m.FreeText)
	}
	return i, nil
}

func (m *MultipleChoiceAnswer) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MultipleChoiceAnswer) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SelectedAnswers) > 0 {
		for _, msg := range m.SelectedAnswers {
			data[i] = 0xa
			i++
			i = encodeVarintGen(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SingleSelectAnswer) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SingleSelectAnswer) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SelectedAnswer != nil {
		data[i] = 0xa
		i++
		i = encodeVarintGen(data, i, uint64(m.SelectedAnswer.Size()))
		n9, err := m.SelectedAnswer.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *SegmentedControlAnswer) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SegmentedControlAnswer) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SelectedAnswer != nil {
		data[i] = 0xa
		i++
		i = encodeVarintGen(data, i, uint64(m.SelectedAnswer.Size()))
		n10, err := m.SelectedAnswer.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *SingleEntryAnswer) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SingleEntryAnswer) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FreeText) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintGen(data, i, uint64(len(m.FreeText)))
		i += copy(data[i:], m.FreeText)
	}
	return i, nil
}

func (m *AnswerOption) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AnswerOption) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintGen(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.FreeText) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintGen(data, i, uint64(len(m.FreeText)))
		i += copy(data[i:], m.FreeText)
	}
	if len(m.SubAnswers) > 0 {
		for k, _ := range m.SubAnswers {
			data[i] = 0x1a
			i++
			v := m.SubAnswers[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovGen(uint64(len(k))) + 1 + msgSize + sovGen(uint64(msgSize))
			i = encodeVarintGen(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintGen(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintGen(data, i, uint64(v.Size()))
			n11, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n11
		}
	}
	return i, nil
}

func (m *AutocompleteAnswerItem) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AutocompleteAnswerItem) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Answer) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintGen(data, i, uint64(len(m.Answer)))
		i += copy(data[i:], m.Answer)
	}
	if len(m.SubAnswers) > 0 {
		for k, _ := range m.SubAnswers {
			data[i] = 0x12
			i++
			v := m.SubAnswers[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovGen(uint64(len(k))) + 1 + msgSize + sovGen(uint64(msgSize))
			i = encodeVarintGen(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintGen(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintGen(data, i, uint64(v.Size()))
			n12, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n12
		}
	}
	return i, nil
}

func (m *AutocompleteAnswer) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AutocompleteAnswer) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			data[i] = 0xa
			i++
			i = encodeVarintGen(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MediaSectionAnswer) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MediaSectionAnswer) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sections) > 0 {
		for _, msg := range m.Sections {
			data[i] = 0xa
			i++
			i = encodeVarintGen(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MediaSectionAnswer_MediaSectionItem) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MediaSectionAnswer_MediaSectionItem) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintGen(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Slots) > 0 {
		for _, msg := range m.Slots {
			data[i] = 0x12
			i++
			i = encodeVarintGen(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MediaSectionAnswer_MediaSectionItem_MediaSlotItem) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MediaSectionAnswer_MediaSectionItem_MediaSlotItem) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SlotID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintGen(data, i, uint64(len(m.SlotID)))
		i += copy(data[i:], m.SlotID)
	}
	if len(m.Name) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintGen(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.MediaID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintGen(data, i, uint64(len(m.MediaID)))
		i += copy(data[i:], m.MediaID)
	}
	if m.Type != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGen(data, i, uint64(m.Type))
	}
	return i, nil
}

func encodeFixed64Gen(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Gen(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintGen(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Answer) Size() (n int) {
	var l int
	_ = l
	l = len(m.QuestionID)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	if m.Answer != nil {
		n += m.Answer.Size()
	}
	return n
}

func (m *Answer_FreeText) Size() (n int) {
	var l int
	_ = l
	if m.FreeText != nil {
		l = m.FreeText.Size()
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}
func (m *Answer_MultipleChoice) Size() (n int) {
	var l int
	_ = l
	if m.MultipleChoice != nil {
		l = m.MultipleChoice.Size()
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}
func (m *Answer_SingleSelect) Size() (n int) {
	var l int
	_ = l
	if m.SingleSelect != nil {
		l = m.SingleSelect.Size()
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}
func (m *Answer_Autocomplete) Size() (n int) {
	var l int
	_ = l
	if m.Autocomplete != nil {
		l = m.Autocomplete.Size()
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}
func (m *Answer_MediaSection) Size() (n int) {
	var l int
	_ = l
	if m.MediaSection != nil {
		l = m.MediaSection.Size()
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}
func (m *Answer_SingleEntry) Size() (n int) {
	var l int
	_ = l
	if m.SingleEntry != nil {
		l = m.SingleEntry.Size()
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}
func (m *Answer_SegmentedControl) Size() (n int) {
	var l int
	_ = l
	if m.SegmentedControl != nil {
		l = m.SegmentedControl.Size()
		n += 2 + l + sovGen(uint64(l))
	}
	return n
}
func (m *FreeTextAnswer) Size() (n int) {
	var l int
	_ = l
	l = len(m.FreeText)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}

func (m *MultipleChoiceAnswer) Size() (n int) {
	var l int
	_ = l
	if len(m.SelectedAnswers) > 0 {
		for _, e := range m.SelectedAnswers {
			l = e.Size()
			n += 1 + l + sovGen(uint64(l))
		}
	}
	return n
}

func (m *SingleSelectAnswer) Size() (n int) {
	var l int
	_ = l
	if m.SelectedAnswer != nil {
		l = m.SelectedAnswer.Size()
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}

func (m *SegmentedControlAnswer) Size() (n int) {
	var l int
	_ = l
	if m.SelectedAnswer != nil {
		l = m.SelectedAnswer.Size()
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}

func (m *SingleEntryAnswer) Size() (n int) {
	var l int
	_ = l
	l = len(m.FreeText)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}

func (m *AnswerOption) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	l = len(m.FreeText)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	if len(m.SubAnswers) > 0 {
		for k, v := range m.SubAnswers {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovGen(uint64(len(k))) + 1 + l + sovGen(uint64(l))
			n += mapEntrySize + 1 + sovGen(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AutocompleteAnswerItem) Size() (n int) {
	var l int
	_ = l
	l = len(m.Answer)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	if len(m.SubAnswers) > 0 {
		for k, v := range m.SubAnswers {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovGen(uint64(len(k))) + 1 + l + sovGen(uint64(l))
			n += mapEntrySize + 1 + sovGen(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AutocompleteAnswer) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGen(uint64(l))
		}
	}
	return n
}

func (m *MediaSectionAnswer) Size() (n int) {
	var l int
	_ = l
	if len(m.Sections) > 0 {
		for _, e := range m.Sections {
			l = e.Size()
			n += 1 + l + sovGen(uint64(l))
		}
	}
	return n
}

func (m *MediaSectionAnswer_MediaSectionItem) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	if len(m.Slots) > 0 {
		for _, e := range m.Slots {
			l = e.Size()
			n += 1 + l + sovGen(uint64(l))
		}
	}
	return n
}

func (m *MediaSectionAnswer_MediaSectionItem_MediaSlotItem) Size() (n int) {
	var l int
	_ = l
	l = len(m.SlotID)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	l = len(m.MediaID)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovGen(uint64(m.Type))
	}
	return n
}

func sovGen(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGen(x uint64) (n int) {
	return sovGen(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Answer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Answer{`,
		`QuestionID:` + fmt.Sprintf("%v", this.QuestionID) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Answer:` + fmt.Sprintf("%v", this.Answer) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Answer_FreeText) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Answer_FreeText{`,
		`FreeText:` + strings.Replace(fmt.Sprintf("%v", this.FreeText), "FreeTextAnswer", "FreeTextAnswer", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Answer_MultipleChoice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Answer_MultipleChoice{`,
		`MultipleChoice:` + strings.Replace(fmt.Sprintf("%v", this.MultipleChoice), "MultipleChoiceAnswer", "MultipleChoiceAnswer", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Answer_SingleSelect) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Answer_SingleSelect{`,
		`SingleSelect:` + strings.Replace(fmt.Sprintf("%v", this.SingleSelect), "SingleSelectAnswer", "SingleSelectAnswer", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Answer_Autocomplete) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Answer_Autocomplete{`,
		`Autocomplete:` + strings.Replace(fmt.Sprintf("%v", this.Autocomplete), "AutocompleteAnswer", "AutocompleteAnswer", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Answer_MediaSection) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Answer_MediaSection{`,
		`MediaSection:` + strings.Replace(fmt.Sprintf("%v", this.MediaSection), "MediaSectionAnswer", "MediaSectionAnswer", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Answer_SingleEntry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Answer_SingleEntry{`,
		`SingleEntry:` + strings.Replace(fmt.Sprintf("%v", this.SingleEntry), "SingleEntryAnswer", "SingleEntryAnswer", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Answer_SegmentedControl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Answer_SegmentedControl{`,
		`SegmentedControl:` + strings.Replace(fmt.Sprintf("%v", this.SegmentedControl), "SegmentedControlAnswer", "SegmentedControlAnswer", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FreeTextAnswer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FreeTextAnswer{`,
		`FreeText:` + fmt.Sprintf("%v", this.FreeText) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MultipleChoiceAnswer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MultipleChoiceAnswer{`,
		`SelectedAnswers:` + strings.Replace(fmt.Sprintf("%v", this.SelectedAnswers), "AnswerOption", "AnswerOption", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SingleSelectAnswer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SingleSelectAnswer{`,
		`SelectedAnswer:` + strings.Replace(fmt.Sprintf("%v", this.SelectedAnswer), "AnswerOption", "AnswerOption", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SegmentedControlAnswer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SegmentedControlAnswer{`,
		`SelectedAnswer:` + strings.Replace(fmt.Sprintf("%v", this.SelectedAnswer), "AnswerOption", "AnswerOption", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SingleEntryAnswer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SingleEntryAnswer{`,
		`FreeText:` + fmt.Sprintf("%v", this.FreeText) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AnswerOption) String() string {
	if this == nil {
		return "nil"
	}
	keysForSubAnswers := make([]string, 0, len(this.SubAnswers))
	for k, _ := range this.SubAnswers {
		keysForSubAnswers = append(keysForSubAnswers, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSubAnswers)
	mapStringForSubAnswers := "map[string]*Answer{"
	for _, k := range keysForSubAnswers {
		mapStringForSubAnswers += fmt.Sprintf("%v: %v,", k, this.SubAnswers[k])
	}
	mapStringForSubAnswers += "}"
	s := strings.Join([]string{`&AnswerOption{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`FreeText:` + fmt.Sprintf("%v", this.FreeText) + `,`,
		`SubAnswers:` + mapStringForSubAnswers + `,`,
		`}`,
	}, "")
	return s
}
func (this *AutocompleteAnswerItem) String() string {
	if this == nil {
		return "nil"
	}
	keysForSubAnswers := make([]string, 0, len(this.SubAnswers))
	for k, _ := range this.SubAnswers {
		keysForSubAnswers = append(keysForSubAnswers, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSubAnswers)
	mapStringForSubAnswers := "map[string]*Answer{"
	for _, k := range keysForSubAnswers {
		mapStringForSubAnswers += fmt.Sprintf("%v: %v,", k, this.SubAnswers[k])
	}
	mapStringForSubAnswers += "}"
	s := strings.Join([]string{`&AutocompleteAnswerItem{`,
		`Answer:` + fmt.Sprintf("%v", this.Answer) + `,`,
		`SubAnswers:` + mapStringForSubAnswers + `,`,
		`}`,
	}, "")
	return s
}
func (this *AutocompleteAnswer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AutocompleteAnswer{`,
		`Items:` + strings.Replace(fmt.Sprintf("%v", this.Items), "AutocompleteAnswerItem", "AutocompleteAnswerItem", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MediaSectionAnswer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MediaSectionAnswer{`,
		`Sections:` + strings.Replace(fmt.Sprintf("%v", this.Sections), "MediaSectionAnswer_MediaSectionItem", "MediaSectionAnswer_MediaSectionItem", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MediaSectionAnswer_MediaSectionItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MediaSectionAnswer_MediaSectionItem{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Slots:` + strings.Replace(fmt.Sprintf("%v", this.Slots), "MediaSectionAnswer_MediaSectionItem_MediaSlotItem", "MediaSectionAnswer_MediaSectionItem_MediaSlotItem", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MediaSectionAnswer_MediaSectionItem_MediaSlotItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MediaSectionAnswer_MediaSectionItem_MediaSlotItem{`,
		`SlotID:` + fmt.Sprintf("%v", this.SlotID) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`MediaID:` + fmt.Sprintf("%v", this.MediaID) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringGen(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Answer) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Answer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Answer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuestionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuestionID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeText", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FreeTextAnswer{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Answer = &Answer_FreeText{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultipleChoice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MultipleChoiceAnswer{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Answer = &Answer_MultipleChoice{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleSelect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SingleSelectAnswer{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Answer = &Answer_SingleSelect{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autocomplete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AutocompleteAnswer{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Answer = &Answer_Autocomplete{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaSection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MediaSectionAnswer{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Answer = &Answer_MediaSection{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SingleEntryAnswer{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Answer = &Answer_SingleEntry{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentedControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SegmentedControlAnswer{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Answer = &Answer_SegmentedControl{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FreeTextAnswer) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FreeTextAnswer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FreeTextAnswer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FreeText = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultipleChoiceAnswer) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultipleChoiceAnswer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultipleChoiceAnswer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectedAnswers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelectedAnswers = append(m.SelectedAnswers, &AnswerOption{})
			if err := m.SelectedAnswers[len(m.SelectedAnswers)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingleSelectAnswer) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleSelectAnswer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleSelectAnswer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectedAnswer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SelectedAnswer == nil {
				m.SelectedAnswer = &AnswerOption{}
			}
			if err := m.SelectedAnswer.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SegmentedControlAnswer) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SegmentedControlAnswer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SegmentedControlAnswer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectedAnswer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SelectedAnswer == nil {
				m.SelectedAnswer = &AnswerOption{}
			}
			if err := m.SelectedAnswer.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingleEntryAnswer) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleEntryAnswer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleEntryAnswer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FreeText = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnswerOption) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnswerOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnswerOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FreeText = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubAnswers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthGen
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthGen
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthGen
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &Answer{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.SubAnswers == nil {
				m.SubAnswers = make(map[string]*Answer)
			}
			m.SubAnswers[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutocompleteAnswerItem) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutocompleteAnswerItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutocompleteAnswerItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Answer = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubAnswers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthGen
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthGen
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthGen
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &Answer{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.SubAnswers == nil {
				m.SubAnswers = make(map[string]*Answer)
			}
			m.SubAnswers[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutocompleteAnswer) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutocompleteAnswer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutocompleteAnswer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &AutocompleteAnswerItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MediaSectionAnswer) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaSectionAnswer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaSectionAnswer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sections = append(m.Sections, &MediaSectionAnswer_MediaSectionItem{})
			if err := m.Sections[len(m.Sections)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MediaSectionAnswer_MediaSectionItem) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaSectionItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaSectionItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slots", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Slots = append(m.Slots, &MediaSectionAnswer_MediaSectionItem_MediaSlotItem{})
			if err := m.Slots[len(m.Slots)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MediaSectionAnswer_MediaSectionItem_MediaSlotItem) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaSlotItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaSlotItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlotID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (MediaType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGen(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGen
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGen
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGen
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGen
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGen
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGen(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGen = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGen   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorGen = []byte{
	// 723 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x55, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0x8e, 0x9d, 0x26, 0x6d, 0xc6, 0x69, 0x7e, 0x56, 0x55, 0x64, 0x02, 0xa4, 0x28, 0x45, 0x08,
	0x51, 0xea, 0x8a, 0xf4, 0x00, 0x05, 0x71, 0x48, 0x93, 0xb4, 0x8d, 0x50, 0x5b, 0x50, 0x0a, 0x88,
	0x53, 0x94, 0x9f, 0x6d, 0x6a, 0x61, 0xc7, 0x21, 0x5e, 0x03, 0xe5, 0xc4, 0x23, 0xf0, 0x18, 0x1c,
	0x91, 0x38, 0x21, 0xf1, 0x00, 0x1c, 0x7b, 0xe4, 0x84, 0x68, 0x91, 0x10, 0x47, 0x1e, 0x81, 0xf1,
	0xae, 0x6d, 0xe2, 0x26, 0x41, 0xea, 0x81, 0xc3, 0x2a, 0xde, 0xf9, 0xf6, 0xfb, 0xe6, 0xdb, 0xd9,
	0xd9, 0x0d, 0x24, 0x7a, 0xb4, 0xaf, 0x0d, 0x86, 0x16, 0xb3, 0x48, 0xdc, 0xb4, 0xba, 0xd4, 0xb0,
	0xf3, 0x2b, 0x3d, 0x9d, 0x1d, 0x3a, 0x6d, 0xad, 0x63, 0x99, 0xab, 0x3d, 0xab, 0x67, 0xad, 0x72,
	0xb8, 0xed, 0x1c, 0xf0, 0x19, 0x9f, 0xf0, 0x2f, 0x41, 0x2b, 0x7e, 0x8a, 0x42, 0xbc, 0xdc, 0xb7,
	0x5f, 0xd1, 0x21, 0x59, 0x02, 0xe5, 0x85, 0x43, 0x6d, 0xa6, 0x5b, 0xfd, 0xa6, 0xde, 0x55, 0xa5,
	0x2b, 0xd2, 0xf5, 0xc4, 0x46, 0xea, 0xf4, 0xdb, 0x22, 0x3c, 0xf2, 0xc2, 0xf5, 0x2a, 0x49, 0xc2,
	0x0c, 0x3b, 0x1a, 0x50, 0x55, 0x76, 0x51, 0xb2, 0x0c, 0x89, 0x83, 0x21, 0xa5, 0x4d, 0x46, 0x5f,
	0x33, 0x15, 0x30, 0xa4, 0x94, 0x72, 0x9a, 0x30, 0xa2, 0x6d, 0x22, 0xb0, 0x8f, 0x71, 0xa1, 0xbe,
	0x1d, 0x21, 0xb7, 0x21, 0x6d, 0x3a, 0x06, 0xd3, 0x07, 0x06, 0x6d, 0x76, 0x0e, 0x2d, 0xbd, 0x43,
	0x55, 0x85, 0x53, 0x2e, 0xf9, 0x94, 0x1d, 0x0f, 0xae, 0x70, 0x34, 0x20, 0xae, 0xc1, 0xbc, 0xad,
	0xf7, 0x7b, 0x48, 0xb3, 0xa9, 0x41, 0x3b, 0x4c, 0x4d, 0x72, 0x5a, 0xde, 0xa7, 0x35, 0x38, 0xd8,
	0xe0, 0x58, 0x40, 0x2a, 0x41, 0xb2, 0xe5, 0x30, 0x0b, 0xcb, 0x80, 0x82, 0x8c, 0xaa, 0xf3, 0x61,
	0x4e, 0x79, 0x04, 0x1b, 0x4d, 0x64, 0xd2, 0xae, 0xde, 0xc2, 0x3c, 0x1d, 0x77, 0xbf, 0x6a, 0x2a,
	0x4c, 0xda, 0x71, 0xc1, 0x86, 0xc0, 0x02, 0xd2, 0x2d, 0x48, 0x7a, 0xee, 0x68, 0x9f, 0x0d, 0x8f,
	0xd4, 0x34, 0xe7, 0x5c, 0x08, 0x9b, 0xab, 0xb9, 0x50, 0x40, 0xb9, 0x07, 0x59, 0x9b, 0xf6, 0x4c,
	0x5c, 0x4f, 0xbb, 0xcd, 0x8e, 0x85, 0x98, 0x65, 0xa8, 0x19, 0xce, 0x2b, 0x04, 0x3c, 0x7f, 0x41,
	0x45, 0xe0, 0x3e, 0x79, 0x63, 0x0e, 0xe2, 0x2d, 0xfe, 0x5d, 0x5c, 0x82, 0x54, 0xb8, 0xc8, 0x24,
	0x3b, 0x7a, 0x1e, 0xfc, 0x00, 0x8b, 0x9b, 0xb0, 0x30, 0xa9, 0xac, 0x44, 0x83, 0x8c, 0xa8, 0x26,
	0x5a, 0x10, 0x7a, 0x36, 0x32, 0xa2, 0x68, 0x61, 0x21, 0xa8, 0x11, 0x0f, 0xef, 0x0d, 0xdc, 0xed,
	0x16, 0x2b, 0x40, 0xc6, 0xeb, 0x4c, 0x56, 0x20, 0x7d, 0x46, 0x85, 0xa7, 0x9d, 0x26, 0xb2, 0x05,
	0xb9, 0xc9, 0xfb, 0x3a, 0xaf, 0xd0, 0x35, 0xc8, 0x8e, 0x15, 0x76, 0xd2, 0xee, 0x3f, 0x4a, 0x90,
	0x1c, 0x25, 0x12, 0x02, 0x72, 0xd0, 0xdb, 0x71, 0xec, 0x6d, 0x19, 0x7b, 0x3a, 0xc4, 0x13, 0x8d,
	0xbd, 0x0e, 0x8a, 0xed, 0xb4, 0x83, 0xc2, 0x44, 0x79, 0x61, 0xae, 0x4e, 0xb2, 0xa2, 0x35, 0x9c,
	0xb6, 0x98, 0xdb, 0xdc, 0x4b, 0xbe, 0x0c, 0xe9, 0x33, 0x21, 0xa2, 0x40, 0xf4, 0x39, 0x3d, 0x12,
	0x59, 0xc9, 0x65, 0x88, 0xbd, 0x6c, 0x19, 0x8e, 0xb8, 0x42, 0x4a, 0x29, 0x15, 0x16, 0xbd, 0x2b,
	0xdf, 0x91, 0x8a, 0x1f, 0x24, 0xc8, 0x8d, 0x37, 0x68, 0x9d, 0x51, 0x93, 0xa4, 0xfc, 0xd3, 0xf7,
	0xd4, 0x2a, 0x61, 0xa3, 0x32, 0x37, 0xaa, 0x4d, 0xef, 0x72, 0x57, 0xe4, 0x7f, 0x58, 0xc6, 0xf6,
	0x18, 0x4f, 0x86, 0xa7, 0x1a, 0xd3, 0x31, 0xa1, 0xdf, 0x59, 0x85, 0x7f, 0xfb, 0x2a, 0x7e, 0x96,
	0x81, 0x8c, 0xdf, 0x31, 0x72, 0x1f, 0xe6, 0xbc, 0x0b, 0xe9, 0x0b, 0x2d, 0x4f, 0xbf, 0x91, 0xa1,
	0x90, 0xab, 0x9a, 0xff, 0x29, 0x41, 0xe6, 0x6c, 0xd0, 0x7d, 0xc7, 0xfa, 0x2d, 0x93, 0x7a, 0x1b,
	0xdc, 0x86, 0x98, 0x6d, 0x58, 0xcc, 0xaf, 0xdf, 0xfa, 0x39, 0xe4, 0xbd, 0x00, 0xb2, 0x79, 0xb2,
	0x37, 0x30, 0x1f, 0x0a, 0x90, 0x8b, 0x30, 0xeb, 0x4a, 0xff, 0x7d, 0x51, 0x01, 0xbb, 0x2e, 0xce,
	0xe1, 0x6a, 0xe0, 0x42, 0xf6, 0xca, 0x3c, 0x27, 0x9e, 0x1f, 0x5c, 0x1b, 0xe5, 0x6b, 0x15, 0x5c,
	0x3b, 0xcb, 0xf5, 0x70, 0xf1, 0xa2, 0xf7, 0xf4, 0xce, 0x20, 0x94, 0x2a, 0x65, 0x43, 0x1e, 0xf7,
	0x11, 0xb8, 0xb1, 0x0e, 0x89, 0x60, 0x42, 0x72, 0x58, 0xca, 0x5a, 0xb5, 0x5e, 0x6e, 0xee, 0x3f,
	0x7b, 0x58, 0x6b, 0x3e, 0xde, 0x7d, 0xb0, 0xbb, 0xf7, 0x74, 0x37, 0x13, 0x21, 0x09, 0x88, 0xd5,
	0x77, 0xca, 0x5b, 0xb5, 0x8c, 0xe4, 0x7e, 0x3e, 0xa9, 0x57, 0x6b, 0x7b, 0x19, 0x79, 0xe3, 0xe6,
	0xf1, 0x49, 0x41, 0xfa, 0x7a, 0x52, 0x88, 0xfc, 0xc6, 0xdf, 0xb7, 0xa7, 0x05, 0xe9, 0x3d, 0x8e,
	0x2f, 0x38, 0x8e, 0x71, 0x7c, 0xc7, 0xf1, 0xeb, 0x14, 0x31, 0xfc, 0x7d, 0xf7, 0xa3, 0x10, 0x69,
	0xc7, 0xf9, 0x7f, 0xc7, 0xda, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xb4, 0x1c, 0x77, 0xc7, 0x7f,
	0x06, 0x00, 0x00,
}
