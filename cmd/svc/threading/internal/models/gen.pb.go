// Code generated by protoc-gen-gogo.
// source: gen.proto
// DO NOT EDIT!

/*
	Package models is a generated protocol buffer package.

	It is generated from these files:
		gen.proto

	It has these top-level messages:
		Reference
		Message
		EndpointList
		Endpoint
		MessageUpdated
		FollowerUpdated
		Attachment
		ImageAttachment
		VideoAttachment
		AudioAttachment
		DocumentAttachment
		GenericAttachment
		VisitAttachment
		CarePlanAttachment
		PaymentRequestAttachment
		Query
		Expr
*/
package models

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import strconv "strconv"

import strings "strings"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
import sort "sort"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Reference_Type int32

const (
	REFERENCE_TYPE_ENTITY Reference_Type = 0
)

var Reference_Type_name = map[int32]string{
	0: "REFERENCE_TYPE_ENTITY",
}
var Reference_Type_value = map[string]int32{
	"REFERENCE_TYPE_ENTITY": 0,
}

func (Reference_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorGen, []int{0, 0} }

type Message_Status int32

const (
	MESSAGE_STATUS_NORMAL  Message_Status = 0
	MESSAGE_STATUS_DELETED Message_Status = 1
)

var Message_Status_name = map[int32]string{
	0: "MESSAGE_STATUS_NORMAL",
	1: "MESSAGE_STATUS_DELETED",
}
var Message_Status_value = map[string]int32{
	"MESSAGE_STATUS_NORMAL":  0,
	"MESSAGE_STATUS_DELETED": 1,
}

func (Message_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptorGen, []int{1, 0} }

type Endpoint_Channel int32

const (
	ENDPOINT_CHANNEL_APP   Endpoint_Channel = 0
	ENDPOINT_CHANNEL_SMS   Endpoint_Channel = 1
	ENDPOINT_CHANNEL_VOICE Endpoint_Channel = 2
	ENDPOINT_CHANNEL_EMAIL Endpoint_Channel = 3
)

var Endpoint_Channel_name = map[int32]string{
	0: "ENDPOINT_CHANNEL_APP",
	1: "ENDPOINT_CHANNEL_SMS",
	2: "ENDPOINT_CHANNEL_VOICE",
	3: "ENDPOINT_CHANNEL_EMAIL",
}
var Endpoint_Channel_value = map[string]int32{
	"ENDPOINT_CHANNEL_APP":   0,
	"ENDPOINT_CHANNEL_SMS":   1,
	"ENDPOINT_CHANNEL_VOICE": 2,
	"ENDPOINT_CHANNEL_EMAIL": 3,
}

func (Endpoint_Channel) EnumDescriptor() ([]byte, []int) { return fileDescriptorGen, []int{3, 0} }

type Attachment_Type int32

const (
	ATTACHMENT_TYPE_IMAGE           Attachment_Type = 0
	ATTACHMENT_TYPE_AUDIO           Attachment_Type = 1
	ATTACHMENT_TYPE_GENERIC_URL     Attachment_Type = 2
	ATTACHMENT_TYPE_CARE_PLAN       Attachment_Type = 3
	ATTACHMENT_TYPE_VISIT           Attachment_Type = 4
	ATTACHMENT_TYPE_VIDEO           Attachment_Type = 5
	ATTACHMENT_TYPE_PAYMENT_REQUEST Attachment_Type = 6
	ATTACHMENT_TYPE_DOCUMENT        Attachment_Type = 7
)

var Attachment_Type_name = map[int32]string{
	0: "ATTACHMENT_TYPE_IMAGE",
	1: "ATTACHMENT_TYPE_AUDIO",
	2: "ATTACHMENT_TYPE_GENERIC_URL",
	3: "ATTACHMENT_TYPE_CARE_PLAN",
	4: "ATTACHMENT_TYPE_VISIT",
	5: "ATTACHMENT_TYPE_VIDEO",
	6: "ATTACHMENT_TYPE_PAYMENT_REQUEST",
	7: "ATTACHMENT_TYPE_DOCUMENT",
}
var Attachment_Type_value = map[string]int32{
	"ATTACHMENT_TYPE_IMAGE":           0,
	"ATTACHMENT_TYPE_AUDIO":           1,
	"ATTACHMENT_TYPE_GENERIC_URL":     2,
	"ATTACHMENT_TYPE_CARE_PLAN":       3,
	"ATTACHMENT_TYPE_VISIT":           4,
	"ATTACHMENT_TYPE_VIDEO":           5,
	"ATTACHMENT_TYPE_PAYMENT_REQUEST": 6,
	"ATTACHMENT_TYPE_DOCUMENT":        7,
}

func (Attachment_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorGen, []int{6, 0} }

type Expr_Flag int32

const (
	EXPR_FLAG_INVALID          Expr_Flag = 0
	EXPR_FLAG_UNREAD           Expr_Flag = 1
	EXPR_FLAG_UNREAD_REFERENCE Expr_Flag = 2
	EXPR_FLAG_FOLLOWING        Expr_Flag = 3
)

var Expr_Flag_name = map[int32]string{
	0: "EXPR_FLAG_INVALID",
	1: "EXPR_FLAG_UNREAD",
	2: "EXPR_FLAG_UNREAD_REFERENCE",
	3: "EXPR_FLAG_FOLLOWING",
}
var Expr_Flag_value = map[string]int32{
	"EXPR_FLAG_INVALID":          0,
	"EXPR_FLAG_UNREAD":           1,
	"EXPR_FLAG_UNREAD_REFERENCE": 2,
	"EXPR_FLAG_FOLLOWING":        3,
}

func (Expr_Flag) EnumDescriptor() ([]byte, []int) { return fileDescriptorGen, []int{16, 0} }

// This is separate from the top-level thread type to handle logical types like "patient"
type Expr_ThreadType int32

const (
	EXPR_THREAD_TYPE_INVALID  Expr_ThreadType = 0
	EXPR_THREAD_TYPE_PATIENT  Expr_ThreadType = 1
	EXPR_THREAD_TYPE_TEAM     Expr_ThreadType = 2
	EXPR_THREAD_TYPE_SUPPORT  Expr_ThreadType = 3
	EXPR_THREAD_TYPE_SECURE   Expr_ThreadType = 4
	EXPR_THREAD_TYPE_STANDARD Expr_ThreadType = 5
)

var Expr_ThreadType_name = map[int32]string{
	0: "EXPR_THREAD_TYPE_INVALID",
	1: "EXPR_THREAD_TYPE_PATIENT",
	2: "EXPR_THREAD_TYPE_TEAM",
	3: "EXPR_THREAD_TYPE_SUPPORT",
	4: "EXPR_THREAD_TYPE_SECURE",
	5: "EXPR_THREAD_TYPE_STANDARD",
}
var Expr_ThreadType_value = map[string]int32{
	"EXPR_THREAD_TYPE_INVALID":  0,
	"EXPR_THREAD_TYPE_PATIENT":  1,
	"EXPR_THREAD_TYPE_TEAM":     2,
	"EXPR_THREAD_TYPE_SUPPORT":  3,
	"EXPR_THREAD_TYPE_SECURE":   4,
	"EXPR_THREAD_TYPE_STANDARD": 5,
}

func (Expr_ThreadType) EnumDescriptor() ([]byte, []int) { return fileDescriptorGen, []int{16, 1} }

type Reference struct {
	Type Reference_Type `protobuf:"varint,1,opt,name=type,proto3,enum=models.Reference_Type" json:"type,omitempty"`
	ID   string         `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Reference) Reset()                    { *m = Reference{} }
func (*Reference) ProtoMessage()               {}
func (*Reference) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{0} }

type Message struct {
	Text            string         `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	Attachments     []*Attachment  `protobuf:"bytes,2,rep,name=attachments" json:"attachments,omitempty"`
	Status          Message_Status `protobuf:"varint,3,opt,name=status,proto3,enum=models.Message_Status" json:"status,omitempty"`
	Source          *Endpoint      `protobuf:"bytes,4,opt,name=source" json:"source,omitempty"`
	Destinations    []*Endpoint    `protobuf:"bytes,5,rep,name=destinations" json:"destinations,omitempty"`
	EditedTimestamp uint64         `protobuf:"varint,6,opt,name=edited_timestamp,proto3" json:"edited_timestamp,omitempty"`
	EditorEntityID  string         `protobuf:"bytes,7,opt,name=editor_entity_id,proto3" json:"editor_entity_id,omitempty"`
	Title           string         `protobuf:"bytes,8,opt,name=title,proto3" json:"title,omitempty"`
	TextRefs        []*Reference   `protobuf:"bytes,9,rep,name=text_refs" json:"text_refs,omitempty"`
	Summary         string         `protobuf:"bytes,10,opt,name=summary,proto3" json:"summary,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{1} }

func (m *Message) GetAttachments() []*Attachment {
	if m != nil {
		return m.Attachments
	}
	return nil
}

func (m *Message) GetSource() *Endpoint {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Message) GetDestinations() []*Endpoint {
	if m != nil {
		return m.Destinations
	}
	return nil
}

func (m *Message) GetTextRefs() []*Reference {
	if m != nil {
		return m.TextRefs
	}
	return nil
}

type EndpointList struct {
	Endpoints []*Endpoint `protobuf:"bytes,1,rep,name=endpoints" json:"endpoints,omitempty"`
}

func (m *EndpointList) Reset()                    { *m = EndpointList{} }
func (*EndpointList) ProtoMessage()               {}
func (*EndpointList) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{2} }

func (m *EndpointList) GetEndpoints() []*Endpoint {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

type Endpoint struct {
	Channel Endpoint_Channel `protobuf:"varint,1,opt,name=channel,proto3,enum=models.Endpoint_Channel" json:"channel,omitempty"`
	ID      string           `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Endpoint) Reset()                    { *m = Endpoint{} }
func (*Endpoint) ProtoMessage()               {}
func (*Endpoint) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{3} }

type MessageUpdated struct {
	ThreadItemID  string   `protobuf:"bytes,1,opt,name=thread_item_id,proto3" json:"thread_item_id,omitempty"`
	ActorEntityID string   `protobuf:"bytes,2,opt,name=actor_entity_id,proto3" json:"actor_entity_id,omitempty"`
	Message       *Message `protobuf:"bytes,3,opt,name=message" json:"message,omitempty"`
}

func (m *MessageUpdated) Reset()                    { *m = MessageUpdated{} }
func (*MessageUpdated) ProtoMessage()               {}
func (*MessageUpdated) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{4} }

func (m *MessageUpdated) GetMessage() *Message {
	if m != nil {
		return m.Message
	}
	return nil
}

type FollowerUpdated struct {
	EntityID string `protobuf:"bytes,1,opt,name=entity_id,proto3" json:"entity_id,omitempty"`
}

func (m *FollowerUpdated) Reset()                    { *m = FollowerUpdated{} }
func (*FollowerUpdated) ProtoMessage()               {}
func (*FollowerUpdated) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{5} }

type Attachment struct {
	Type  Attachment_Type `protobuf:"varint,1,opt,name=type,proto3,enum=models.Attachment_Type" json:"type,omitempty"`
	Title string          `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	URL   string          `protobuf:"bytes,3,opt,name=url,proto3" json:"url,omitempty"`
	// Types that are valid to be assigned to Data:
	//	*Attachment_Image
	//	*Attachment_Audio
	//	*Attachment_Generic
	//	*Attachment_Visit
	//	*Attachment_CarePlan
	//	*Attachment_Video
	//	*Attachment_PaymentRequest
	//	*Attachment_Document
	Data isAttachment_Data `protobuf_oneof:"data"`
}

func (m *Attachment) Reset()                    { *m = Attachment{} }
func (*Attachment) ProtoMessage()               {}
func (*Attachment) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{6} }

type isAttachment_Data interface {
	isAttachment_Data()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Attachment_Image struct {
	Image *ImageAttachment `protobuf:"bytes,10,opt,name=image,oneof"`
}
type Attachment_Audio struct {
	Audio *AudioAttachment `protobuf:"bytes,11,opt,name=audio,oneof"`
}
type Attachment_Generic struct {
	Generic *GenericAttachment `protobuf:"bytes,12,opt,name=generic,oneof"`
}
type Attachment_Visit struct {
	Visit *VisitAttachment `protobuf:"bytes,13,opt,name=visit,oneof"`
}
type Attachment_CarePlan struct {
	CarePlan *CarePlanAttachment `protobuf:"bytes,14,opt,name=care_plan,oneof"`
}
type Attachment_Video struct {
	Video *VideoAttachment `protobuf:"bytes,15,opt,name=video,oneof"`
}
type Attachment_PaymentRequest struct {
	PaymentRequest *PaymentRequestAttachment `protobuf:"bytes,16,opt,name=payment_request,oneof"`
}
type Attachment_Document struct {
	Document *DocumentAttachment `protobuf:"bytes,17,opt,name=document,oneof"`
}

func (*Attachment_Image) isAttachment_Data()          {}
func (*Attachment_Audio) isAttachment_Data()          {}
func (*Attachment_Generic) isAttachment_Data()        {}
func (*Attachment_Visit) isAttachment_Data()          {}
func (*Attachment_CarePlan) isAttachment_Data()       {}
func (*Attachment_Video) isAttachment_Data()          {}
func (*Attachment_PaymentRequest) isAttachment_Data() {}
func (*Attachment_Document) isAttachment_Data()       {}

func (m *Attachment) GetData() isAttachment_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Attachment) GetImage() *ImageAttachment {
	if x, ok := m.GetData().(*Attachment_Image); ok {
		return x.Image
	}
	return nil
}

func (m *Attachment) GetAudio() *AudioAttachment {
	if x, ok := m.GetData().(*Attachment_Audio); ok {
		return x.Audio
	}
	return nil
}

func (m *Attachment) GetGeneric() *GenericAttachment {
	if x, ok := m.GetData().(*Attachment_Generic); ok {
		return x.Generic
	}
	return nil
}

func (m *Attachment) GetVisit() *VisitAttachment {
	if x, ok := m.GetData().(*Attachment_Visit); ok {
		return x.Visit
	}
	return nil
}

func (m *Attachment) GetCarePlan() *CarePlanAttachment {
	if x, ok := m.GetData().(*Attachment_CarePlan); ok {
		return x.CarePlan
	}
	return nil
}

func (m *Attachment) GetVideo() *VideoAttachment {
	if x, ok := m.GetData().(*Attachment_Video); ok {
		return x.Video
	}
	return nil
}

func (m *Attachment) GetPaymentRequest() *PaymentRequestAttachment {
	if x, ok := m.GetData().(*Attachment_PaymentRequest); ok {
		return x.PaymentRequest
	}
	return nil
}

func (m *Attachment) GetDocument() *DocumentAttachment {
	if x, ok := m.GetData().(*Attachment_Document); ok {
		return x.Document
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Attachment) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Attachment_OneofMarshaler, _Attachment_OneofUnmarshaler, _Attachment_OneofSizer, []interface{}{
		(*Attachment_Image)(nil),
		(*Attachment_Audio)(nil),
		(*Attachment_Generic)(nil),
		(*Attachment_Visit)(nil),
		(*Attachment_CarePlan)(nil),
		(*Attachment_Video)(nil),
		(*Attachment_PaymentRequest)(nil),
		(*Attachment_Document)(nil),
	}
}

func _Attachment_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Attachment)
	// data
	switch x := m.Data.(type) {
	case *Attachment_Image:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Image); err != nil {
			return err
		}
	case *Attachment_Audio:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Audio); err != nil {
			return err
		}
	case *Attachment_Generic:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Generic); err != nil {
			return err
		}
	case *Attachment_Visit:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Visit); err != nil {
			return err
		}
	case *Attachment_CarePlan:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CarePlan); err != nil {
			return err
		}
	case *Attachment_Video:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Video); err != nil {
			return err
		}
	case *Attachment_PaymentRequest:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PaymentRequest); err != nil {
			return err
		}
	case *Attachment_Document:
		_ = b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Document); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Attachment.Data has unexpected type %T", x)
	}
	return nil
}

func _Attachment_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Attachment)
	switch tag {
	case 10: // data.image
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImageAttachment)
		err := b.DecodeMessage(msg)
		m.Data = &Attachment_Image{msg}
		return true, err
	case 11: // data.audio
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AudioAttachment)
		err := b.DecodeMessage(msg)
		m.Data = &Attachment_Audio{msg}
		return true, err
	case 12: // data.generic
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GenericAttachment)
		err := b.DecodeMessage(msg)
		m.Data = &Attachment_Generic{msg}
		return true, err
	case 13: // data.visit
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VisitAttachment)
		err := b.DecodeMessage(msg)
		m.Data = &Attachment_Visit{msg}
		return true, err
	case 14: // data.care_plan
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CarePlanAttachment)
		err := b.DecodeMessage(msg)
		m.Data = &Attachment_CarePlan{msg}
		return true, err
	case 15: // data.video
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VideoAttachment)
		err := b.DecodeMessage(msg)
		m.Data = &Attachment_Video{msg}
		return true, err
	case 16: // data.payment_request
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PaymentRequestAttachment)
		err := b.DecodeMessage(msg)
		m.Data = &Attachment_PaymentRequest{msg}
		return true, err
	case 17: // data.document
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DocumentAttachment)
		err := b.DecodeMessage(msg)
		m.Data = &Attachment_Document{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Attachment_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Attachment)
	// data
	switch x := m.Data.(type) {
	case *Attachment_Image:
		s := proto.Size(x.Image)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Attachment_Audio:
		s := proto.Size(x.Audio)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Attachment_Generic:
		s := proto.Size(x.Generic)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Attachment_Visit:
		s := proto.Size(x.Visit)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Attachment_CarePlan:
		s := proto.Size(x.CarePlan)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Attachment_Video:
		s := proto.Size(x.Video)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Attachment_PaymentRequest:
		s := proto.Size(x.PaymentRequest)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Attachment_Document:
		s := proto.Size(x.Document)
		n += proto.SizeVarint(17<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ImageAttachment struct {
	Mimetype string `protobuf:"bytes,1,opt,name=mimetype,proto3" json:"mimetype,omitempty"`
	MediaID  string `protobuf:"bytes,2,opt,name=media_id,proto3" json:"media_id,omitempty"`
	Width    uint32 `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
	Height   uint32 `protobuf:"varint,4,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *ImageAttachment) Reset()                    { *m = ImageAttachment{} }
func (*ImageAttachment) ProtoMessage()               {}
func (*ImageAttachment) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{7} }

type VideoAttachment struct {
	Mimetype   string `protobuf:"bytes,1,opt,name=mimetype,proto3" json:"mimetype,omitempty"`
	MediaID    string `protobuf:"bytes,2,opt,name=media_id,proto3" json:"media_id,omitempty"`
	DurationNS uint64 `protobuf:"varint,4,opt,name=duration_ns,proto3" json:"duration_ns,omitempty"`
}

func (m *VideoAttachment) Reset()                    { *m = VideoAttachment{} }
func (*VideoAttachment) ProtoMessage()               {}
func (*VideoAttachment) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{8} }

type AudioAttachment struct {
	Mimetype                    string `protobuf:"bytes,1,opt,name=mimetype,proto3" json:"mimetype,omitempty"`
	MediaID                     string `protobuf:"bytes,2,opt,name=media_id,proto3" json:"media_id,omitempty"`
	DeprecatedDurationInSeconds uint32 `protobuf:"varint,3,opt,name=deprecated_duration_in_seconds,proto3" json:"deprecated_duration_in_seconds,omitempty"`
	DurationNS                  uint64 `protobuf:"varint,4,opt,name=duration_ns,proto3" json:"duration_ns,omitempty"`
}

func (m *AudioAttachment) Reset()                    { *m = AudioAttachment{} }
func (*AudioAttachment) ProtoMessage()               {}
func (*AudioAttachment) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{9} }

type DocumentAttachment struct {
	Mimetype string `protobuf:"bytes,1,opt,name=mimetype,proto3" json:"mimetype,omitempty"`
	MediaID  string `protobuf:"bytes,2,opt,name=media_id,proto3" json:"media_id,omitempty"`
	Name     string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *DocumentAttachment) Reset()                    { *m = DocumentAttachment{} }
func (*DocumentAttachment) ProtoMessage()               {}
func (*DocumentAttachment) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{10} }

type GenericAttachment struct {
	Mimetype string `protobuf:"bytes,1,opt,name=mimetype,proto3" json:"mimetype,omitempty"`
	URL      string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *GenericAttachment) Reset()                    { *m = GenericAttachment{} }
func (*GenericAttachment) ProtoMessage()               {}
func (*GenericAttachment) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{11} }

type VisitAttachment struct {
	VisitID   string `protobuf:"bytes,1,opt,name=visit_id,proto3" json:"visit_id,omitempty"`
	VisitName string `protobuf:"bytes,2,opt,name=visit_name,proto3" json:"visit_name,omitempty"`
}

func (m *VisitAttachment) Reset()                    { *m = VisitAttachment{} }
func (*VisitAttachment) ProtoMessage()               {}
func (*VisitAttachment) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{12} }

type CarePlanAttachment struct {
	CarePlanID   string `protobuf:"bytes,1,opt,name=care_plan_id,proto3" json:"care_plan_id,omitempty"`
	CarePlanName string `protobuf:"bytes,2,opt,name=care_plan_name,proto3" json:"care_plan_name,omitempty"`
}

func (m *CarePlanAttachment) Reset()                    { *m = CarePlanAttachment{} }
func (*CarePlanAttachment) ProtoMessage()               {}
func (*CarePlanAttachment) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{13} }

type PaymentRequestAttachment struct {
	PaymentID string `protobuf:"bytes,1,opt,name=payment_id,proto3" json:"payment_id,omitempty"`
}

func (m *PaymentRequestAttachment) Reset()                    { *m = PaymentRequestAttachment{} }
func (*PaymentRequestAttachment) ProtoMessage()               {}
func (*PaymentRequestAttachment) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{14} }

type Query struct {
	// All expressions are required to match (i.e. AND)
	Expressions []*Expr `protobuf:"bytes,1,rep,name=expressions" json:"expressions,omitempty"`
}

func (m *Query) Reset()                    { *m = Query{} }
func (*Query) ProtoMessage()               {}
func (*Query) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{15} }

func (m *Query) GetExpressions() []*Expr {
	if m != nil {
		return m.Expressions
	}
	return nil
}

type Expr struct {
	Not bool `protobuf:"varint,1,opt,name=not,proto3" json:"not,omitempty"`
	// Types that are valid to be assigned to Value:
	//	*Expr_Token
	//	*Expr_Flag_
	//	*Expr_ThreadType_
	Value isExpr_Value `protobuf_oneof:"value"`
}

func (m *Expr) Reset()                    { *m = Expr{} }
func (*Expr) ProtoMessage()               {}
func (*Expr) Descriptor() ([]byte, []int) { return fileDescriptorGen, []int{16} }

type isExpr_Value interface {
	isExpr_Value()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Expr_Token struct {
	Token string `protobuf:"bytes,2,opt,name=token,proto3,oneof"`
}
type Expr_Flag_ struct {
	Flag Expr_Flag `protobuf:"varint,3,opt,name=flag,proto3,enum=models.Expr_Flag,oneof"`
}
type Expr_ThreadType_ struct {
	ThreadType Expr_ThreadType `protobuf:"varint,4,opt,name=thread_type,proto3,enum=models.Expr_ThreadType,oneof"`
}

func (*Expr_Token) isExpr_Value()       {}
func (*Expr_Flag_) isExpr_Value()       {}
func (*Expr_ThreadType_) isExpr_Value() {}

func (m *Expr) GetValue() isExpr_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Expr) GetToken() string {
	if x, ok := m.GetValue().(*Expr_Token); ok {
		return x.Token
	}
	return ""
}

func (m *Expr) GetFlag() Expr_Flag {
	if x, ok := m.GetValue().(*Expr_Flag_); ok {
		return x.Flag
	}
	return EXPR_FLAG_INVALID
}

func (m *Expr) GetThreadType() Expr_ThreadType {
	if x, ok := m.GetValue().(*Expr_ThreadType_); ok {
		return x.ThreadType
	}
	return EXPR_THREAD_TYPE_INVALID
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Expr) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Expr_OneofMarshaler, _Expr_OneofUnmarshaler, _Expr_OneofSizer, []interface{}{
		(*Expr_Token)(nil),
		(*Expr_Flag_)(nil),
		(*Expr_ThreadType_)(nil),
	}
}

func _Expr_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Expr)
	// value
	switch x := m.Value.(type) {
	case *Expr_Token:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Token)
	case *Expr_Flag_:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Flag))
	case *Expr_ThreadType_:
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.ThreadType))
	case nil:
	default:
		return fmt.Errorf("Expr.Value has unexpected type %T", x)
	}
	return nil
}

func _Expr_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Expr)
	switch tag {
	case 2: // value.token
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &Expr_Token{x}
		return true, err
	case 3: // value.flag
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Expr_Flag_{Expr_Flag(x)}
		return true, err
	case 4: // value.thread_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Expr_ThreadType_{Expr_ThreadType(x)}
		return true, err
	default:
		return false, nil
	}
}

func _Expr_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Expr)
	// value
	switch x := m.Value.(type) {
	case *Expr_Token:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Token)))
		n += len(x.Token)
	case *Expr_Flag_:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Flag))
	case *Expr_ThreadType_:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.ThreadType))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*Reference)(nil), "models.Reference")
	proto.RegisterType((*Message)(nil), "models.Message")
	proto.RegisterType((*EndpointList)(nil), "models.EndpointList")
	proto.RegisterType((*Endpoint)(nil), "models.Endpoint")
	proto.RegisterType((*MessageUpdated)(nil), "models.MessageUpdated")
	proto.RegisterType((*FollowerUpdated)(nil), "models.FollowerUpdated")
	proto.RegisterType((*Attachment)(nil), "models.Attachment")
	proto.RegisterType((*ImageAttachment)(nil), "models.ImageAttachment")
	proto.RegisterType((*VideoAttachment)(nil), "models.VideoAttachment")
	proto.RegisterType((*AudioAttachment)(nil), "models.AudioAttachment")
	proto.RegisterType((*DocumentAttachment)(nil), "models.DocumentAttachment")
	proto.RegisterType((*GenericAttachment)(nil), "models.GenericAttachment")
	proto.RegisterType((*VisitAttachment)(nil), "models.VisitAttachment")
	proto.RegisterType((*CarePlanAttachment)(nil), "models.CarePlanAttachment")
	proto.RegisterType((*PaymentRequestAttachment)(nil), "models.PaymentRequestAttachment")
	proto.RegisterType((*Query)(nil), "models.Query")
	proto.RegisterType((*Expr)(nil), "models.Expr")
	proto.RegisterEnum("models.Reference_Type", Reference_Type_name, Reference_Type_value)
	proto.RegisterEnum("models.Message_Status", Message_Status_name, Message_Status_value)
	proto.RegisterEnum("models.Endpoint_Channel", Endpoint_Channel_name, Endpoint_Channel_value)
	proto.RegisterEnum("models.Attachment_Type", Attachment_Type_name, Attachment_Type_value)
	proto.RegisterEnum("models.Expr_Flag", Expr_Flag_name, Expr_Flag_value)
	proto.RegisterEnum("models.Expr_ThreadType", Expr_ThreadType_name, Expr_ThreadType_value)
}
func (x Reference_Type) String() string {
	s, ok := Reference_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Message_Status) String() string {
	s, ok := Message_Status_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Endpoint_Channel) String() string {
	s, ok := Endpoint_Channel_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Attachment_Type) String() string {
	s, ok := Attachment_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Expr_Flag) String() string {
	s, ok := Expr_Flag_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Expr_ThreadType) String() string {
	s, ok := Expr_ThreadType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Reference) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Reference)
	if !ok {
		that2, ok := that.(Reference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	return true
}
func (this *Message) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Message)
	if !ok {
		that2, ok := that.(Message)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Text != that1.Text {
		return false
	}
	if len(this.Attachments) != len(that1.Attachments) {
		return false
	}
	for i := range this.Attachments {
		if !this.Attachments[i].Equal(that1.Attachments[i]) {
			return false
		}
	}
	if this.Status != that1.Status {
		return false
	}
	if !this.Source.Equal(that1.Source) {
		return false
	}
	if len(this.Destinations) != len(that1.Destinations) {
		return false
	}
	for i := range this.Destinations {
		if !this.Destinations[i].Equal(that1.Destinations[i]) {
			return false
		}
	}
	if this.EditedTimestamp != that1.EditedTimestamp {
		return false
	}
	if this.EditorEntityID != that1.EditorEntityID {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if len(this.TextRefs) != len(that1.TextRefs) {
		return false
	}
	for i := range this.TextRefs {
		if !this.TextRefs[i].Equal(that1.TextRefs[i]) {
			return false
		}
	}
	if this.Summary != that1.Summary {
		return false
	}
	return true
}
func (this *EndpointList) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EndpointList)
	if !ok {
		that2, ok := that.(EndpointList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Endpoints) != len(that1.Endpoints) {
		return false
	}
	for i := range this.Endpoints {
		if !this.Endpoints[i].Equal(that1.Endpoints[i]) {
			return false
		}
	}
	return true
}
func (this *Endpoint) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Endpoint)
	if !ok {
		that2, ok := that.(Endpoint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	return true
}
func (this *MessageUpdated) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MessageUpdated)
	if !ok {
		that2, ok := that.(MessageUpdated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ThreadItemID != that1.ThreadItemID {
		return false
	}
	if this.ActorEntityID != that1.ActorEntityID {
		return false
	}
	if !this.Message.Equal(that1.Message) {
		return false
	}
	return true
}
func (this *FollowerUpdated) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FollowerUpdated)
	if !ok {
		that2, ok := that.(FollowerUpdated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.EntityID != that1.EntityID {
		return false
	}
	return true
}
func (this *Attachment) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Attachment)
	if !ok {
		that2, ok := that.(Attachment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if this.URL != that1.URL {
		return false
	}
	if that1.Data == nil {
		if this.Data != nil {
			return false
		}
	} else if this.Data == nil {
		return false
	} else if !this.Data.Equal(that1.Data) {
		return false
	}
	return true
}
func (this *Attachment_Image) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Attachment_Image)
	if !ok {
		that2, ok := that.(Attachment_Image)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Image.Equal(that1.Image) {
		return false
	}
	return true
}
func (this *Attachment_Audio) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Attachment_Audio)
	if !ok {
		that2, ok := that.(Attachment_Audio)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Audio.Equal(that1.Audio) {
		return false
	}
	return true
}
func (this *Attachment_Generic) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Attachment_Generic)
	if !ok {
		that2, ok := that.(Attachment_Generic)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Generic.Equal(that1.Generic) {
		return false
	}
	return true
}
func (this *Attachment_Visit) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Attachment_Visit)
	if !ok {
		that2, ok := that.(Attachment_Visit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Visit.Equal(that1.Visit) {
		return false
	}
	return true
}
func (this *Attachment_CarePlan) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Attachment_CarePlan)
	if !ok {
		that2, ok := that.(Attachment_CarePlan)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.CarePlan.Equal(that1.CarePlan) {
		return false
	}
	return true
}
func (this *Attachment_Video) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Attachment_Video)
	if !ok {
		that2, ok := that.(Attachment_Video)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Video.Equal(that1.Video) {
		return false
	}
	return true
}
func (this *Attachment_PaymentRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Attachment_PaymentRequest)
	if !ok {
		that2, ok := that.(Attachment_PaymentRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.PaymentRequest.Equal(that1.PaymentRequest) {
		return false
	}
	return true
}
func (this *Attachment_Document) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Attachment_Document)
	if !ok {
		that2, ok := that.(Attachment_Document)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Document.Equal(that1.Document) {
		return false
	}
	return true
}
func (this *ImageAttachment) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ImageAttachment)
	if !ok {
		that2, ok := that.(ImageAttachment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Mimetype != that1.Mimetype {
		return false
	}
	if this.MediaID != that1.MediaID {
		return false
	}
	if this.Width != that1.Width {
		return false
	}
	if this.Height != that1.Height {
		return false
	}
	return true
}
func (this *VideoAttachment) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*VideoAttachment)
	if !ok {
		that2, ok := that.(VideoAttachment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Mimetype != that1.Mimetype {
		return false
	}
	if this.MediaID != that1.MediaID {
		return false
	}
	if this.DurationNS != that1.DurationNS {
		return false
	}
	return true
}
func (this *AudioAttachment) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AudioAttachment)
	if !ok {
		that2, ok := that.(AudioAttachment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Mimetype != that1.Mimetype {
		return false
	}
	if this.MediaID != that1.MediaID {
		return false
	}
	if this.DeprecatedDurationInSeconds != that1.DeprecatedDurationInSeconds {
		return false
	}
	if this.DurationNS != that1.DurationNS {
		return false
	}
	return true
}
func (this *DocumentAttachment) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DocumentAttachment)
	if !ok {
		that2, ok := that.(DocumentAttachment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Mimetype != that1.Mimetype {
		return false
	}
	if this.MediaID != that1.MediaID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *GenericAttachment) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GenericAttachment)
	if !ok {
		that2, ok := that.(GenericAttachment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Mimetype != that1.Mimetype {
		return false
	}
	if this.URL != that1.URL {
		return false
	}
	return true
}
func (this *VisitAttachment) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*VisitAttachment)
	if !ok {
		that2, ok := that.(VisitAttachment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.VisitID != that1.VisitID {
		return false
	}
	if this.VisitName != that1.VisitName {
		return false
	}
	return true
}
func (this *CarePlanAttachment) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CarePlanAttachment)
	if !ok {
		that2, ok := that.(CarePlanAttachment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.CarePlanID != that1.CarePlanID {
		return false
	}
	if this.CarePlanName != that1.CarePlanName {
		return false
	}
	return true
}
func (this *PaymentRequestAttachment) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PaymentRequestAttachment)
	if !ok {
		that2, ok := that.(PaymentRequestAttachment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.PaymentID != that1.PaymentID {
		return false
	}
	return true
}
func (this *Query) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Query)
	if !ok {
		that2, ok := that.(Query)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Expressions) != len(that1.Expressions) {
		return false
	}
	for i := range this.Expressions {
		if !this.Expressions[i].Equal(that1.Expressions[i]) {
			return false
		}
	}
	return true
}
func (this *Expr) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Expr)
	if !ok {
		that2, ok := that.(Expr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Not != that1.Not {
		return false
	}
	if that1.Value == nil {
		if this.Value != nil {
			return false
		}
	} else if this.Value == nil {
		return false
	} else if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *Expr_Token) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Expr_Token)
	if !ok {
		that2, ok := that.(Expr_Token)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	return true
}
func (this *Expr_Flag_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Expr_Flag_)
	if !ok {
		that2, ok := that.(Expr_Flag_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Flag != that1.Flag {
		return false
	}
	return true
}
func (this *Expr_ThreadType_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Expr_ThreadType_)
	if !ok {
		that2, ok := that.(Expr_ThreadType_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ThreadType != that1.ThreadType {
		return false
	}
	return true
}
func (this *Reference) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&models.Reference{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Message) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&models.Message{")
	s = append(s, "Text: "+fmt.Sprintf("%#v", this.Text)+",\n")
	if this.Attachments != nil {
		s = append(s, "Attachments: "+fmt.Sprintf("%#v", this.Attachments)+",\n")
	}
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	if this.Source != nil {
		s = append(s, "Source: "+fmt.Sprintf("%#v", this.Source)+",\n")
	}
	if this.Destinations != nil {
		s = append(s, "Destinations: "+fmt.Sprintf("%#v", this.Destinations)+",\n")
	}
	s = append(s, "EditedTimestamp: "+fmt.Sprintf("%#v", this.EditedTimestamp)+",\n")
	s = append(s, "EditorEntityID: "+fmt.Sprintf("%#v", this.EditorEntityID)+",\n")
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	if this.TextRefs != nil {
		s = append(s, "TextRefs: "+fmt.Sprintf("%#v", this.TextRefs)+",\n")
	}
	s = append(s, "Summary: "+fmt.Sprintf("%#v", this.Summary)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EndpointList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&models.EndpointList{")
	if this.Endpoints != nil {
		s = append(s, "Endpoints: "+fmt.Sprintf("%#v", this.Endpoints)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Endpoint) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&models.Endpoint{")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MessageUpdated) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&models.MessageUpdated{")
	s = append(s, "ThreadItemID: "+fmt.Sprintf("%#v", this.ThreadItemID)+",\n")
	s = append(s, "ActorEntityID: "+fmt.Sprintf("%#v", this.ActorEntityID)+",\n")
	if this.Message != nil {
		s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FollowerUpdated) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&models.FollowerUpdated{")
	s = append(s, "EntityID: "+fmt.Sprintf("%#v", this.EntityID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Attachment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&models.Attachment{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	s = append(s, "URL: "+fmt.Sprintf("%#v", this.URL)+",\n")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Attachment_Image) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&models.Attachment_Image{` +
		`Image:` + fmt.Sprintf("%#v", this.Image) + `}`}, ", ")
	return s
}
func (this *Attachment_Audio) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&models.Attachment_Audio{` +
		`Audio:` + fmt.Sprintf("%#v", this.Audio) + `}`}, ", ")
	return s
}
func (this *Attachment_Generic) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&models.Attachment_Generic{` +
		`Generic:` + fmt.Sprintf("%#v", this.Generic) + `}`}, ", ")
	return s
}
func (this *Attachment_Visit) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&models.Attachment_Visit{` +
		`Visit:` + fmt.Sprintf("%#v", this.Visit) + `}`}, ", ")
	return s
}
func (this *Attachment_CarePlan) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&models.Attachment_CarePlan{` +
		`CarePlan:` + fmt.Sprintf("%#v", this.CarePlan) + `}`}, ", ")
	return s
}
func (this *Attachment_Video) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&models.Attachment_Video{` +
		`Video:` + fmt.Sprintf("%#v", this.Video) + `}`}, ", ")
	return s
}
func (this *Attachment_PaymentRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&models.Attachment_PaymentRequest{` +
		`PaymentRequest:` + fmt.Sprintf("%#v", this.PaymentRequest) + `}`}, ", ")
	return s
}
func (this *Attachment_Document) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&models.Attachment_Document{` +
		`Document:` + fmt.Sprintf("%#v", this.Document) + `}`}, ", ")
	return s
}
func (this *ImageAttachment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&models.ImageAttachment{")
	s = append(s, "Mimetype: "+fmt.Sprintf("%#v", this.Mimetype)+",\n")
	s = append(s, "MediaID: "+fmt.Sprintf("%#v", this.MediaID)+",\n")
	s = append(s, "Width: "+fmt.Sprintf("%#v", this.Width)+",\n")
	s = append(s, "Height: "+fmt.Sprintf("%#v", this.Height)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VideoAttachment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&models.VideoAttachment{")
	s = append(s, "Mimetype: "+fmt.Sprintf("%#v", this.Mimetype)+",\n")
	s = append(s, "MediaID: "+fmt.Sprintf("%#v", this.MediaID)+",\n")
	s = append(s, "DurationNS: "+fmt.Sprintf("%#v", this.DurationNS)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AudioAttachment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&models.AudioAttachment{")
	s = append(s, "Mimetype: "+fmt.Sprintf("%#v", this.Mimetype)+",\n")
	s = append(s, "MediaID: "+fmt.Sprintf("%#v", this.MediaID)+",\n")
	s = append(s, "DeprecatedDurationInSeconds: "+fmt.Sprintf("%#v", this.DeprecatedDurationInSeconds)+",\n")
	s = append(s, "DurationNS: "+fmt.Sprintf("%#v", this.DurationNS)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DocumentAttachment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&models.DocumentAttachment{")
	s = append(s, "Mimetype: "+fmt.Sprintf("%#v", this.Mimetype)+",\n")
	s = append(s, "MediaID: "+fmt.Sprintf("%#v", this.MediaID)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GenericAttachment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&models.GenericAttachment{")
	s = append(s, "Mimetype: "+fmt.Sprintf("%#v", this.Mimetype)+",\n")
	s = append(s, "URL: "+fmt.Sprintf("%#v", this.URL)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VisitAttachment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&models.VisitAttachment{")
	s = append(s, "VisitID: "+fmt.Sprintf("%#v", this.VisitID)+",\n")
	s = append(s, "VisitName: "+fmt.Sprintf("%#v", this.VisitName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CarePlanAttachment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&models.CarePlanAttachment{")
	s = append(s, "CarePlanID: "+fmt.Sprintf("%#v", this.CarePlanID)+",\n")
	s = append(s, "CarePlanName: "+fmt.Sprintf("%#v", this.CarePlanName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PaymentRequestAttachment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&models.PaymentRequestAttachment{")
	s = append(s, "PaymentID: "+fmt.Sprintf("%#v", this.PaymentID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Query) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&models.Query{")
	if this.Expressions != nil {
		s = append(s, "Expressions: "+fmt.Sprintf("%#v", this.Expressions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Expr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&models.Expr{")
	s = append(s, "Not: "+fmt.Sprintf("%#v", this.Not)+",\n")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Expr_Token) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&models.Expr_Token{` +
		`Token:` + fmt.Sprintf("%#v", this.Token) + `}`}, ", ")
	return s
}
func (this *Expr_Flag_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&models.Expr_Flag_{` +
		`Flag:` + fmt.Sprintf("%#v", this.Flag) + `}`}, ", ")
	return s
}
func (this *Expr_ThreadType_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&models.Expr_ThreadType_{` +
		`ThreadType:` + fmt.Sprintf("%#v", this.ThreadType) + `}`}, ", ")
	return s
}
func valueToGoStringGen(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringGen(m github_com_gogo_protobuf_proto.Message) string {
	e := github_com_gogo_protobuf_proto.GetUnsafeExtensionsMap(m)
	if e == nil {
		return "nil"
	}
	s := "proto.NewUnsafeXXX_InternalExtensions(map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "})"
	return s
}
func (m *Reference) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Reference) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGen(data, i, uint64(m.Type))
	}
	if len(m.ID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintGen(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	return i, nil
}

func (m *Message) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Message) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintGen(data, i, uint64(len(m.Text)))
		i += copy(data[i:], m.Text)
	}
	if len(m.Attachments) > 0 {
		for _, msg := range m.Attachments {
			data[i] = 0x12
			i++
			i = encodeVarintGen(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Status != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGen(data, i, uint64(m.Status))
	}
	if m.Source != nil {
		data[i] = 0x22
		i++
		i = encodeVarintGen(data, i, uint64(m.Source.Size()))
		n1, err := m.Source.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Destinations) > 0 {
		for _, msg := range m.Destinations {
			data[i] = 0x2a
			i++
			i = encodeVarintGen(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.EditedTimestamp != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintGen(data, i, uint64(m.EditedTimestamp))
	}
	if len(m.EditorEntityID) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintGen(data, i, uint64(len(m.EditorEntityID)))
		i += copy(data[i:], m.EditorEntityID)
	}
	if len(m.Title) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintGen(data, i, uint64(len(m.Title)))
		i += copy(data[i:], m.Title)
	}
	if len(m.TextRefs) > 0 {
		for _, msg := range m.TextRefs {
			data[i] = 0x4a
			i++
			i = encodeVarintGen(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Summary) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintGen(data, i, uint64(len(m.Summary)))
		i += copy(data[i:], m.Summary)
	}
	return i, nil
}

func (m *EndpointList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EndpointList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Endpoints) > 0 {
		for _, msg := range m.Endpoints {
			data[i] = 0xa
			i++
			i = encodeVarintGen(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Endpoint) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Endpoint) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Channel != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGen(data, i, uint64(m.Channel))
	}
	if len(m.ID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintGen(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	return i, nil
}

func (m *MessageUpdated) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MessageUpdated) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ThreadItemID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintGen(data, i, uint64(len(m.ThreadItemID)))
		i += copy(data[i:], m.ThreadItemID)
	}
	if len(m.ActorEntityID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintGen(data, i, uint64(len(m.ActorEntityID)))
		i += copy(data[i:], m.ActorEntityID)
	}
	if m.Message != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintGen(data, i, uint64(m.Message.Size()))
		n2, err := m.Message.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *FollowerUpdated) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FollowerUpdated) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EntityID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintGen(data, i, uint64(len(m.EntityID)))
		i += copy(data[i:], m.EntityID)
	}
	return i, nil
}

func (m *Attachment) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Attachment) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGen(data, i, uint64(m.Type))
	}
	if len(m.Title) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintGen(data, i, uint64(len(m.Title)))
		i += copy(data[i:], m.Title)
	}
	if len(m.URL) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintGen(data, i, uint64(len(m.URL)))
		i += copy(data[i:], m.URL)
	}
	if m.Data != nil {
		nn3, err := m.Data.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	return i, nil
}

func (m *Attachment_Image) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Image != nil {
		data[i] = 0x52
		i++
		i = encodeVarintGen(data, i, uint64(m.Image.Size()))
		n4, err := m.Image.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *Attachment_Audio) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Audio != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintGen(data, i, uint64(m.Audio.Size()))
		n5, err := m.Audio.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *Attachment_Generic) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Generic != nil {
		data[i] = 0x62
		i++
		i = encodeVarintGen(data, i, uint64(m.Generic.Size()))
		n6, err := m.Generic.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *Attachment_Visit) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Visit != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintGen(data, i, uint64(m.Visit.Size()))
		n7, err := m.Visit.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *Attachment_CarePlan) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.CarePlan != nil {
		data[i] = 0x72
		i++
		i = encodeVarintGen(data, i, uint64(m.CarePlan.Size()))
		n8, err := m.CarePlan.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *Attachment_Video) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Video != nil {
		data[i] = 0x7a
		i++
		i = encodeVarintGen(data, i, uint64(m.Video.Size()))
		n9, err := m.Video.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *Attachment_PaymentRequest) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.PaymentRequest != nil {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintGen(data, i, uint64(m.PaymentRequest.Size()))
		n10, err := m.PaymentRequest.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *Attachment_Document) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Document != nil {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintGen(data, i, uint64(m.Document.Size()))
		n11, err := m.Document.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *ImageAttachment) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ImageAttachment) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mimetype) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintGen(data, i, uint64(len(m.Mimetype)))
		i += copy(data[i:], m.Mimetype)
	}
	if len(m.MediaID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintGen(data, i, uint64(len(m.MediaID)))
		i += copy(data[i:], m.MediaID)
	}
	if m.Width != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGen(data, i, uint64(m.Width))
	}
	if m.Height != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGen(data, i, uint64(m.Height))
	}
	return i, nil
}

func (m *VideoAttachment) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VideoAttachment) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mimetype) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintGen(data, i, uint64(len(m.Mimetype)))
		i += copy(data[i:], m.Mimetype)
	}
	if len(m.MediaID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintGen(data, i, uint64(len(m.MediaID)))
		i += copy(data[i:], m.MediaID)
	}
	if m.DurationNS != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGen(data, i, uint64(m.DurationNS))
	}
	return i, nil
}

func (m *AudioAttachment) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AudioAttachment) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mimetype) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintGen(data, i, uint64(len(m.Mimetype)))
		i += copy(data[i:], m.Mimetype)
	}
	if len(m.MediaID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintGen(data, i, uint64(len(m.MediaID)))
		i += copy(data[i:], m.MediaID)
	}
	if m.DeprecatedDurationInSeconds != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGen(data, i, uint64(m.DeprecatedDurationInSeconds))
	}
	if m.DurationNS != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGen(data, i, uint64(m.DurationNS))
	}
	return i, nil
}

func (m *DocumentAttachment) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DocumentAttachment) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mimetype) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintGen(data, i, uint64(len(m.Mimetype)))
		i += copy(data[i:], m.Mimetype)
	}
	if len(m.MediaID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintGen(data, i, uint64(len(m.MediaID)))
		i += copy(data[i:], m.MediaID)
	}
	if len(m.Name) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintGen(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	return i, nil
}

func (m *GenericAttachment) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GenericAttachment) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mimetype) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintGen(data, i, uint64(len(m.Mimetype)))
		i += copy(data[i:], m.Mimetype)
	}
	if len(m.URL) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintGen(data, i, uint64(len(m.URL)))
		i += copy(data[i:], m.URL)
	}
	return i, nil
}

func (m *VisitAttachment) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VisitAttachment) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VisitID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintGen(data, i, uint64(len(m.VisitID)))
		i += copy(data[i:], m.VisitID)
	}
	if len(m.VisitName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintGen(data, i, uint64(len(m.VisitName)))
		i += copy(data[i:], m.VisitName)
	}
	return i, nil
}

func (m *CarePlanAttachment) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CarePlanAttachment) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CarePlanID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintGen(data, i, uint64(len(m.CarePlanID)))
		i += copy(data[i:], m.CarePlanID)
	}
	if len(m.CarePlanName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintGen(data, i, uint64(len(m.CarePlanName)))
		i += copy(data[i:], m.CarePlanName)
	}
	return i, nil
}

func (m *PaymentRequestAttachment) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PaymentRequestAttachment) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PaymentID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintGen(data, i, uint64(len(m.PaymentID)))
		i += copy(data[i:], m.PaymentID)
	}
	return i, nil
}

func (m *Query) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Query) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Expressions) > 0 {
		for _, msg := range m.Expressions {
			data[i] = 0xa
			i++
			i = encodeVarintGen(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Expr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Expr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Not {
		data[i] = 0x8
		i++
		if m.Not {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Value != nil {
		nn12, err := m.Value.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn12
	}
	return i, nil
}

func (m *Expr_Token) MarshalTo(data []byte) (int, error) {
	i := 0
	data[i] = 0x12
	i++
	i = encodeVarintGen(data, i, uint64(len(m.Token)))
	i += copy(data[i:], m.Token)
	return i, nil
}
func (m *Expr_Flag_) MarshalTo(data []byte) (int, error) {
	i := 0
	data[i] = 0x18
	i++
	i = encodeVarintGen(data, i, uint64(m.Flag))
	return i, nil
}
func (m *Expr_ThreadType_) MarshalTo(data []byte) (int, error) {
	i := 0
	data[i] = 0x20
	i++
	i = encodeVarintGen(data, i, uint64(m.ThreadType))
	return i, nil
}
func encodeFixed64Gen(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Gen(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintGen(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Reference) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovGen(uint64(m.Type))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}

func (m *Message) Size() (n int) {
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	if len(m.Attachments) > 0 {
		for _, e := range m.Attachments {
			l = e.Size()
			n += 1 + l + sovGen(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovGen(uint64(m.Status))
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovGen(uint64(l))
	}
	if len(m.Destinations) > 0 {
		for _, e := range m.Destinations {
			l = e.Size()
			n += 1 + l + sovGen(uint64(l))
		}
	}
	if m.EditedTimestamp != 0 {
		n += 1 + sovGen(uint64(m.EditedTimestamp))
	}
	l = len(m.EditorEntityID)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	if len(m.TextRefs) > 0 {
		for _, e := range m.TextRefs {
			l = e.Size()
			n += 1 + l + sovGen(uint64(l))
		}
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}

func (m *EndpointList) Size() (n int) {
	var l int
	_ = l
	if len(m.Endpoints) > 0 {
		for _, e := range m.Endpoints {
			l = e.Size()
			n += 1 + l + sovGen(uint64(l))
		}
	}
	return n
}

func (m *Endpoint) Size() (n int) {
	var l int
	_ = l
	if m.Channel != 0 {
		n += 1 + sovGen(uint64(m.Channel))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}

func (m *MessageUpdated) Size() (n int) {
	var l int
	_ = l
	l = len(m.ThreadItemID)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	l = len(m.ActorEntityID)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}

func (m *FollowerUpdated) Size() (n int) {
	var l int
	_ = l
	l = len(m.EntityID)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}

func (m *Attachment) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovGen(uint64(m.Type))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	if m.Data != nil {
		n += m.Data.Size()
	}
	return n
}

func (m *Attachment_Image) Size() (n int) {
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}
func (m *Attachment_Audio) Size() (n int) {
	var l int
	_ = l
	if m.Audio != nil {
		l = m.Audio.Size()
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}
func (m *Attachment_Generic) Size() (n int) {
	var l int
	_ = l
	if m.Generic != nil {
		l = m.Generic.Size()
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}
func (m *Attachment_Visit) Size() (n int) {
	var l int
	_ = l
	if m.Visit != nil {
		l = m.Visit.Size()
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}
func (m *Attachment_CarePlan) Size() (n int) {
	var l int
	_ = l
	if m.CarePlan != nil {
		l = m.CarePlan.Size()
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}
func (m *Attachment_Video) Size() (n int) {
	var l int
	_ = l
	if m.Video != nil {
		l = m.Video.Size()
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}
func (m *Attachment_PaymentRequest) Size() (n int) {
	var l int
	_ = l
	if m.PaymentRequest != nil {
		l = m.PaymentRequest.Size()
		n += 2 + l + sovGen(uint64(l))
	}
	return n
}
func (m *Attachment_Document) Size() (n int) {
	var l int
	_ = l
	if m.Document != nil {
		l = m.Document.Size()
		n += 2 + l + sovGen(uint64(l))
	}
	return n
}
func (m *ImageAttachment) Size() (n int) {
	var l int
	_ = l
	l = len(m.Mimetype)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	l = len(m.MediaID)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovGen(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovGen(uint64(m.Height))
	}
	return n
}

func (m *VideoAttachment) Size() (n int) {
	var l int
	_ = l
	l = len(m.Mimetype)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	l = len(m.MediaID)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	if m.DurationNS != 0 {
		n += 1 + sovGen(uint64(m.DurationNS))
	}
	return n
}

func (m *AudioAttachment) Size() (n int) {
	var l int
	_ = l
	l = len(m.Mimetype)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	l = len(m.MediaID)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	if m.DeprecatedDurationInSeconds != 0 {
		n += 1 + sovGen(uint64(m.DeprecatedDurationInSeconds))
	}
	if m.DurationNS != 0 {
		n += 1 + sovGen(uint64(m.DurationNS))
	}
	return n
}

func (m *DocumentAttachment) Size() (n int) {
	var l int
	_ = l
	l = len(m.Mimetype)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	l = len(m.MediaID)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}

func (m *GenericAttachment) Size() (n int) {
	var l int
	_ = l
	l = len(m.Mimetype)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}

func (m *VisitAttachment) Size() (n int) {
	var l int
	_ = l
	l = len(m.VisitID)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	l = len(m.VisitName)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}

func (m *CarePlanAttachment) Size() (n int) {
	var l int
	_ = l
	l = len(m.CarePlanID)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	l = len(m.CarePlanName)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}

func (m *PaymentRequestAttachment) Size() (n int) {
	var l int
	_ = l
	l = len(m.PaymentID)
	if l > 0 {
		n += 1 + l + sovGen(uint64(l))
	}
	return n
}

func (m *Query) Size() (n int) {
	var l int
	_ = l
	if len(m.Expressions) > 0 {
		for _, e := range m.Expressions {
			l = e.Size()
			n += 1 + l + sovGen(uint64(l))
		}
	}
	return n
}

func (m *Expr) Size() (n int) {
	var l int
	_ = l
	if m.Not {
		n += 2
	}
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Expr_Token) Size() (n int) {
	var l int
	_ = l
	l = len(m.Token)
	n += 1 + l + sovGen(uint64(l))
	return n
}
func (m *Expr_Flag_) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGen(uint64(m.Flag))
	return n
}
func (m *Expr_ThreadType_) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGen(uint64(m.ThreadType))
	return n
}

func sovGen(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGen(x uint64) (n int) {
	return sovGen(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Reference) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Reference{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Message) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Message{`,
		`Text:` + fmt.Sprintf("%v", this.Text) + `,`,
		`Attachments:` + strings.Replace(fmt.Sprintf("%v", this.Attachments), "Attachment", "Attachment", 1) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Source:` + strings.Replace(fmt.Sprintf("%v", this.Source), "Endpoint", "Endpoint", 1) + `,`,
		`Destinations:` + strings.Replace(fmt.Sprintf("%v", this.Destinations), "Endpoint", "Endpoint", 1) + `,`,
		`EditedTimestamp:` + fmt.Sprintf("%v", this.EditedTimestamp) + `,`,
		`EditorEntityID:` + fmt.Sprintf("%v", this.EditorEntityID) + `,`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`TextRefs:` + strings.Replace(fmt.Sprintf("%v", this.TextRefs), "Reference", "Reference", 1) + `,`,
		`Summary:` + fmt.Sprintf("%v", this.Summary) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EndpointList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EndpointList{`,
		`Endpoints:` + strings.Replace(fmt.Sprintf("%v", this.Endpoints), "Endpoint", "Endpoint", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Endpoint) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Endpoint{`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MessageUpdated) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MessageUpdated{`,
		`ThreadItemID:` + fmt.Sprintf("%v", this.ThreadItemID) + `,`,
		`ActorEntityID:` + fmt.Sprintf("%v", this.ActorEntityID) + `,`,
		`Message:` + strings.Replace(fmt.Sprintf("%v", this.Message), "Message", "Message", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FollowerUpdated) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FollowerUpdated{`,
		`EntityID:` + fmt.Sprintf("%v", this.EntityID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Attachment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Attachment{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`URL:` + fmt.Sprintf("%v", this.URL) + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Attachment_Image) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Attachment_Image{`,
		`Image:` + strings.Replace(fmt.Sprintf("%v", this.Image), "ImageAttachment", "ImageAttachment", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Attachment_Audio) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Attachment_Audio{`,
		`Audio:` + strings.Replace(fmt.Sprintf("%v", this.Audio), "AudioAttachment", "AudioAttachment", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Attachment_Generic) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Attachment_Generic{`,
		`Generic:` + strings.Replace(fmt.Sprintf("%v", this.Generic), "GenericAttachment", "GenericAttachment", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Attachment_Visit) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Attachment_Visit{`,
		`Visit:` + strings.Replace(fmt.Sprintf("%v", this.Visit), "VisitAttachment", "VisitAttachment", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Attachment_CarePlan) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Attachment_CarePlan{`,
		`CarePlan:` + strings.Replace(fmt.Sprintf("%v", this.CarePlan), "CarePlanAttachment", "CarePlanAttachment", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Attachment_Video) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Attachment_Video{`,
		`Video:` + strings.Replace(fmt.Sprintf("%v", this.Video), "VideoAttachment", "VideoAttachment", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Attachment_PaymentRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Attachment_PaymentRequest{`,
		`PaymentRequest:` + strings.Replace(fmt.Sprintf("%v", this.PaymentRequest), "PaymentRequestAttachment", "PaymentRequestAttachment", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Attachment_Document) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Attachment_Document{`,
		`Document:` + strings.Replace(fmt.Sprintf("%v", this.Document), "DocumentAttachment", "DocumentAttachment", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImageAttachment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImageAttachment{`,
		`Mimetype:` + fmt.Sprintf("%v", this.Mimetype) + `,`,
		`MediaID:` + fmt.Sprintf("%v", this.MediaID) + `,`,
		`Width:` + fmt.Sprintf("%v", this.Width) + `,`,
		`Height:` + fmt.Sprintf("%v", this.Height) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VideoAttachment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VideoAttachment{`,
		`Mimetype:` + fmt.Sprintf("%v", this.Mimetype) + `,`,
		`MediaID:` + fmt.Sprintf("%v", this.MediaID) + `,`,
		`DurationNS:` + fmt.Sprintf("%v", this.DurationNS) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AudioAttachment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AudioAttachment{`,
		`Mimetype:` + fmt.Sprintf("%v", this.Mimetype) + `,`,
		`MediaID:` + fmt.Sprintf("%v", this.MediaID) + `,`,
		`DeprecatedDurationInSeconds:` + fmt.Sprintf("%v", this.DeprecatedDurationInSeconds) + `,`,
		`DurationNS:` + fmt.Sprintf("%v", this.DurationNS) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DocumentAttachment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DocumentAttachment{`,
		`Mimetype:` + fmt.Sprintf("%v", this.Mimetype) + `,`,
		`MediaID:` + fmt.Sprintf("%v", this.MediaID) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GenericAttachment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GenericAttachment{`,
		`Mimetype:` + fmt.Sprintf("%v", this.Mimetype) + `,`,
		`URL:` + fmt.Sprintf("%v", this.URL) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VisitAttachment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VisitAttachment{`,
		`VisitID:` + fmt.Sprintf("%v", this.VisitID) + `,`,
		`VisitName:` + fmt.Sprintf("%v", this.VisitName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CarePlanAttachment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CarePlanAttachment{`,
		`CarePlanID:` + fmt.Sprintf("%v", this.CarePlanID) + `,`,
		`CarePlanName:` + fmt.Sprintf("%v", this.CarePlanName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PaymentRequestAttachment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PaymentRequestAttachment{`,
		`PaymentID:` + fmt.Sprintf("%v", this.PaymentID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Query) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Query{`,
		`Expressions:` + strings.Replace(fmt.Sprintf("%v", this.Expressions), "Expr", "Expr", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Expr) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Expr{`,
		`Not:` + fmt.Sprintf("%v", this.Not) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Expr_Token) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Expr_Token{`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Expr_Flag_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Expr_Flag_{`,
		`Flag:` + fmt.Sprintf("%v", this.Flag) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Expr_ThreadType_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Expr_ThreadType_{`,
		`ThreadType:` + fmt.Sprintf("%v", this.ThreadType) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringGen(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Reference) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (Reference_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attachments = append(m.Attachments, &Attachment{})
			if err := m.Attachments[len(m.Attachments)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Status |= (Message_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &Endpoint{}
			}
			if err := m.Source.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destinations = append(m.Destinations, &Endpoint{})
			if err := m.Destinations[len(m.Destinations)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditedTimestamp", wireType)
			}
			m.EditedTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EditedTimestamp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditorEntityID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EditorEntityID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TextRefs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TextRefs = append(m.TextRefs, &Reference{})
			if err := m.TextRefs[len(m.TextRefs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoints = append(m.Endpoints, &Endpoint{})
			if err := m.Endpoints[len(m.Endpoints)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Endpoint) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Endpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Endpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Channel |= (Endpoint_Channel(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageUpdated) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreadItemID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThreadItemID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActorEntityID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActorEntityID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &Message{}
			}
			if err := m.Message.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FollowerUpdated) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FollowerUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FollowerUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Attachment) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (Attachment_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ImageAttachment{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Attachment_Image{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AudioAttachment{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Attachment_Audio{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Generic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GenericAttachment{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Attachment_Generic{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VisitAttachment{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Attachment_Visit{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarePlan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CarePlanAttachment{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Attachment_CarePlan{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VideoAttachment{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Attachment_Video{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PaymentRequestAttachment{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Attachment_PaymentRequest{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Document", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DocumentAttachment{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Attachment_Document{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageAttachment) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageAttachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageAttachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mimetype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mimetype = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Width |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Height |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoAttachment) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoAttachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoAttachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mimetype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mimetype = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationNS", wireType)
			}
			m.DurationNS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DurationNS |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AudioAttachment) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AudioAttachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AudioAttachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mimetype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mimetype = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedDurationInSeconds", wireType)
			}
			m.DeprecatedDurationInSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DeprecatedDurationInSeconds |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationNS", wireType)
			}
			m.DurationNS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DurationNS |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentAttachment) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentAttachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentAttachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mimetype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mimetype = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenericAttachment) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenericAttachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenericAttachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mimetype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mimetype = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VisitAttachment) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VisitAttachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VisitAttachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VisitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VisitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VisitName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VisitName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CarePlanAttachment) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CarePlanAttachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CarePlanAttachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarePlanID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarePlanID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarePlanName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarePlanName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaymentRequestAttachment) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaymentRequestAttachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaymentRequestAttachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Query) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Query: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Query: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expressions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expressions = append(m.Expressions, &Expr{})
			if err := m.Expressions[len(m.Expressions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGen
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Not", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Not = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGen
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Expr_Token{string(data[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			var v Expr_Flag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (Expr_Flag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Expr_Flag_{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreadType", wireType)
			}
			var v Expr_ThreadType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGen
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (Expr_ThreadType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Expr_ThreadType_{v}
		default:
			iNdEx = preIndex
			skippy, err := skipGen(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGen
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGen(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGen
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGen
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGen
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGen
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGen
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGen(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGen = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGen   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("gen.proto", fileDescriptorGen) }

var fileDescriptorGen = []byte{
	// 1389 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x56, 0x3b, 0x8f, 0xdb, 0xc6,
	0x16, 0x16, 0xf5, 0x5c, 0x1d, 0x69, 0x25, 0xee, 0x5c, 0x3f, 0xb8, 0xeb, 0x6b, 0x49, 0x4b, 0xfb,
	0xfa, 0xee, 0x35, 0x7c, 0x65, 0x60, 0x5d, 0x1a, 0x41, 0x40, 0x89, 0xb3, 0xbb, 0x04, 0x24, 0x4a,
	0xa6, 0xa8, 0x4d, 0x5c, 0x11, 0xb4, 0x38, 0x2b, 0x11, 0x11, 0x49, 0x85, 0x1c, 0xd9, 0xde, 0x2e,
	0xe9, 0xd2, 0x25, 0x3f, 0x23, 0x55, 0xfe, 0x41, 0x80, 0x94, 0x29, 0x52, 0xb8, 0x4c, 0x25, 0xc4,
	0x4c, 0x93, 0xd2, 0x4d, 0xfa, 0x80, 0x43, 0x3d, 0x56, 0x8f, 0x00, 0x71, 0xc7, 0x99, 0xef, 0x9b,
	0xef, 0x9c, 0x99, 0x39, 0xe7, 0x1b, 0x42, 0x7e, 0x48, 0xdc, 0xfa, 0xc4, 0xf7, 0xa8, 0x87, 0xb2,
	0x8e, 0x67, 0x91, 0x71, 0x70, 0xf4, 0xff, 0xa1, 0x4d, 0x47, 0xd3, 0x57, 0xf5, 0x81, 0xe7, 0x3c,
	0x1d, 0x7a, 0x43, 0xef, 0x29, 0x83, 0x5f, 0x4d, 0xaf, 0xd8, 0x88, 0x0d, 0xd8, 0x57, 0xbc, 0x4c,
	0x1c, 0x41, 0x5e, 0x23, 0x57, 0xc4, 0x27, 0xee, 0x80, 0xa0, 0x87, 0x90, 0xa6, 0xd7, 0x13, 0x22,
	0x70, 0x35, 0xee, 0xa4, 0x74, 0x7a, 0xa7, 0x1e, 0x4b, 0xd6, 0x97, 0x84, 0xba, 0x7e, 0x3d, 0x21,
	0x08, 0x41, 0xd2, 0xb6, 0x84, 0x64, 0x8d, 0x3b, 0xc9, 0x37, 0xb2, 0xe1, 0xac, 0x9a, 0x54, 0x64,
	0xf1, 0x18, 0xd2, 0x0c, 0x3b, 0x84, 0xdb, 0x1a, 0x3e, 0xc3, 0x1a, 0x56, 0x9b, 0xd8, 0xd0, 0x5f,
	0x76, 0xb1, 0x81, 0x55, 0x5d, 0xd1, 0x5f, 0xf2, 0x09, 0xf1, 0xeb, 0x14, 0xe4, 0xda, 0x24, 0x08,
	0xcc, 0x21, 0x41, 0x45, 0x48, 0x53, 0xf2, 0x96, 0xb2, 0x40, 0x79, 0xf4, 0x5f, 0x28, 0x98, 0x94,
	0x9a, 0x83, 0x91, 0x43, 0x5c, 0x1a, 0x08, 0xc9, 0x5a, 0xea, 0xa4, 0x70, 0x8a, 0x16, 0xd1, 0xa5,
	0x25, 0x84, 0x1e, 0x41, 0x36, 0xa0, 0x26, 0x9d, 0x06, 0x42, 0x6a, 0x3d, 0xc3, 0xb9, 0x6e, 0xbd,
	0xc7, 0x50, 0x54, 0x83, 0x6c, 0xe0, 0x4d, 0xfd, 0x01, 0x11, 0xd2, 0x35, 0xee, 0xa4, 0x70, 0xca,
	0x2f, 0x78, 0xd8, 0xb5, 0x26, 0x9e, 0xcd, 0x94, 0x8a, 0x16, 0x09, 0xa8, 0xed, 0x9a, 0xd4, 0xf6,
	0xdc, 0x40, 0xc8, 0xb0, 0x98, 0xdb, 0x3c, 0x01, 0x78, 0x62, 0xd9, 0x94, 0x58, 0x06, 0xb5, 0x1d,
	0x12, 0x50, 0xd3, 0x99, 0x08, 0xd9, 0x1a, 0x77, 0x92, 0x46, 0x4f, 0x62, 0xc4, 0xf3, 0x0d, 0xe2,
	0x52, 0x9b, 0x5e, 0x1b, 0xb6, 0x25, 0xe4, 0xd8, 0x99, 0xa0, 0x70, 0x56, 0x2d, 0x61, 0x86, 0x61,
	0x06, 0x29, 0x32, 0xda, 0x87, 0x0c, 0xb5, 0xe9, 0x98, 0x08, 0x7b, 0x6c, 0xc7, 0x0f, 0x21, 0x1f,
	0xed, 0xdf, 0xf0, 0xc9, 0x55, 0x20, 0xe4, 0x59, 0xec, 0x83, 0xad, 0xd3, 0x46, 0x65, 0xc8, 0x05,
	0x53, 0xc7, 0x31, 0xfd, 0x6b, 0x01, 0xa2, 0x65, 0xe2, 0xa7, 0x90, 0x9d, 0xef, 0xf0, 0x10, 0x6e,
	0xb7, 0x71, 0xaf, 0x27, 0x9d, 0x63, 0xa3, 0xa7, 0x4b, 0x7a, 0xbf, 0x67, 0xa8, 0x1d, 0xad, 0x2d,
	0xb5, 0xf8, 0x04, 0x3a, 0x82, 0x3b, 0x1b, 0x90, 0x8c, 0x5b, 0x58, 0xc7, 0x32, 0xcf, 0x89, 0xcf,
	0xa0, 0xb8, 0xd8, 0x5a, 0xcb, 0x0e, 0x28, 0x7a, 0x00, 0x79, 0x32, 0x1f, 0x07, 0x02, 0xb7, 0xfb,
	0x0c, 0xc4, 0x9f, 0x38, 0xd8, 0x5b, 0x1e, 0xc8, 0xff, 0x20, 0x37, 0x18, 0x99, 0xae, 0x4b, 0xc6,
	0xf3, 0x2a, 0x11, 0x36, 0xf9, 0xf5, 0x66, 0x8c, 0xef, 0xac, 0x93, 0x29, 0xe4, 0x16, 0xb0, 0x00,
	0xb7, 0xb0, 0x2a, 0x77, 0x3b, 0x8a, 0xaa, 0x1b, 0xcd, 0x0b, 0x49, 0x55, 0x71, 0xcb, 0x90, 0xba,
	0x5d, 0x3e, 0xb1, 0x13, 0xe9, 0xb5, 0x7b, 0x3c, 0x17, 0xed, 0x6d, 0x0b, 0xb9, 0xec, 0x28, 0x4d,
	0xcc, 0x27, 0x77, 0x62, 0xb8, 0x2d, 0x29, 0x2d, 0x3e, 0x25, 0x7e, 0xc3, 0x41, 0x69, 0x5e, 0x23,
	0xfd, 0x89, 0x65, 0x52, 0x62, 0xa1, 0x13, 0x28, 0xd1, 0x91, 0x4f, 0x4c, 0xcb, 0xb0, 0x29, 0x71,
	0xa2, 0xdb, 0x63, 0xc5, 0xd8, 0xe0, 0xc3, 0x59, 0xb5, 0xa8, 0x33, 0x44, 0xa1, 0xc4, 0x51, 0x64,
	0xf4, 0x18, 0xca, 0xe6, 0x60, 0xfd, 0xa2, 0xe3, 0x4d, 0x1d, 0x84, 0xb3, 0xea, 0xbe, 0x34, 0xb8,
	0x79, 0xcf, 0x35, 0xc8, 0x39, 0x71, 0x1c, 0x56, 0xa2, 0x85, 0xd3, 0xf2, 0x46, 0x89, 0x8a, 0xa7,
	0x50, 0x3e, 0xf3, 0xc6, 0x63, 0xef, 0x0d, 0xf1, 0x17, 0xa9, 0x54, 0xa3, 0x5b, 0x58, 0x48, 0xc7,
	0x59, 0x14, 0xc3, 0x59, 0x75, 0x6f, 0xa1, 0x2a, 0xfe, 0x92, 0x01, 0xb8, 0xd1, 0x06, 0xff, 0x59,
	0x6b, 0xd3, 0xbb, 0xdb, 0x8d, 0x12, 0xf7, 0xe9, 0xb2, 0xe6, 0x58, 0xb6, 0xe8, 0x16, 0xa4, 0xa6,
	0xfe, 0x98, 0xa5, 0x95, 0x6f, 0xe4, 0xc2, 0x59, 0x35, 0xd5, 0xd7, 0x5a, 0xe8, 0x04, 0x32, 0xb6,
	0x13, 0xa5, 0x0b, 0x2c, 0xdd, 0xa5, 0x98, 0x12, 0x4d, 0xae, 0x14, 0x2f, 0x12, 0x11, 0xd3, 0x9c,
	0x5a, 0xb6, 0x27, 0x14, 0xd6, 0x99, 0x52, 0x34, 0xb9, 0xc6, 0x7c, 0x02, 0xb9, 0x21, 0x71, 0x89,
	0x6f, 0x0f, 0x84, 0x22, 0xe3, 0x1e, 0x2e, 0xb8, 0xe7, 0xf1, 0xf4, 0xa6, 0xee, 0x6b, 0x3b, 0xb0,
	0xa9, 0xb0, 0xbf, 0xae, 0x7b, 0x19, 0x4d, 0xae, 0x31, 0x9f, 0x42, 0x7e, 0x60, 0xfa, 0xc4, 0x98,
	0x8c, 0x4d, 0x57, 0x28, 0x31, 0xf6, 0xd1, 0x82, 0xdd, 0x34, 0x7d, 0xd2, 0x1d, 0x9b, 0xee, 0xb6,
	0xb4, 0x45, 0x3c, 0xa1, 0xbc, 0x29, 0x6d, 0x91, 0xf5, 0x94, 0x9f, 0x43, 0x79, 0x62, 0x5e, 0x47,
	0x03, 0xc3, 0x27, 0x5f, 0x4e, 0x49, 0x40, 0x05, 0x9e, 0xad, 0xa9, 0x2d, 0xd6, 0x74, 0x63, 0x58,
	0x8b, 0xd1, 0xb5, 0xc5, 0x75, 0xd8, 0xb3, 0xbc, 0xc1, 0x34, 0x1a, 0x09, 0x07, 0xeb, 0x69, 0xc9,
	0xf3, 0xf9, 0x9b, 0x7c, 0xf1, 0x4f, 0x6e, 0xe5, 0x96, 0x92, 0xae, 0x4b, 0xcd, 0x8b, 0x36, 0x56,
	0xf5, 0xd8, 0x2e, 0x95, 0xb6, 0x74, 0x8e, 0xf9, 0xc4, 0x2e, 0x48, 0xea, 0xcb, 0x4a, 0x87, 0xe7,
	0x50, 0x15, 0xee, 0x6d, 0x42, 0xe7, 0x58, 0xc5, 0x9a, 0xd2, 0x34, 0xfa, 0x5a, 0x8b, 0x4f, 0xa2,
	0xfb, 0x70, 0xb8, 0x49, 0x68, 0x4a, 0x1a, 0x36, 0xba, 0x2d, 0x49, 0xe5, 0x53, 0xbb, 0xa4, 0x2f,
	0x95, 0x9e, 0xa2, 0xf3, 0xe9, 0xdd, 0x90, 0x8c, 0x3b, 0x7c, 0x06, 0x3d, 0x80, 0xea, 0x26, 0xd4,
	0x95, 0x5e, 0xb2, 0x81, 0x86, 0x5f, 0xf4, 0x71, 0x4f, 0xe7, 0xb3, 0xe8, 0xdf, 0x20, 0x6c, 0x92,
	0xe4, 0x4e, 0xb3, 0x1f, 0x8d, 0xf8, 0x5c, 0x23, 0x0b, 0x69, 0xcb, 0xa4, 0xa6, 0x68, 0x42, 0x79,
	0xa3, 0xbc, 0x10, 0x0f, 0x7b, 0x8e, 0xed, 0x90, 0x65, 0x59, 0xe7, 0xd1, 0x7d, 0xd8, 0x73, 0x88,
	0x65, 0x9b, 0xab, 0x76, 0x2b, 0x84, 0xb3, 0x6a, 0xae, 0x1d, 0xcd, 0xc5, 0x86, 0xfa, 0xc6, 0xb6,
	0xe8, 0x88, 0xd5, 0xf3, 0x3e, 0x2a, 0x41, 0x76, 0x44, 0xec, 0xe1, 0x88, 0x32, 0xc7, 0xdf, 0x17,
	0x87, 0x50, 0xde, 0xb8, 0xe4, 0x8f, 0x0f, 0xf1, 0x00, 0x0a, 0xd6, 0xd4, 0x67, 0x0f, 0x84, 0xe1,
	0x06, 0x4c, 0x38, 0xdd, 0x28, 0x85, 0xb3, 0x2a, 0xc8, 0xf3, 0x69, 0xb5, 0x27, 0x7e, 0xcb, 0x41,
	0x79, 0xa3, 0x03, 0x3e, 0x3e, 0xd2, 0x23, 0xa8, 0x58, 0x64, 0xe2, 0x93, 0x41, 0x64, 0x07, 0xc6,
	0x32, 0xa8, 0xed, 0x1a, 0x01, 0x19, 0x78, 0xae, 0x15, 0xcc, 0x77, 0xf9, 0x8f, 0x32, 0xea, 0x01,
	0xda, 0xae, 0xba, 0x8f, 0xcf, 0xa9, 0x08, 0x69, 0xd7, 0x74, 0x62, 0x1b, 0xcb, 0x8b, 0xcf, 0xe1,
	0x60, 0xab, 0x77, 0x77, 0x68, 0xce, 0x3d, 0x26, 0xb9, 0xe6, 0x31, 0xa2, 0x1c, 0x5d, 0xc6, 0x5a,
	0x33, 0x47, 0xc1, 0x59, 0xd3, 0xaf, 0x1c, 0x8f, 0x05, 0x67, 0x34, 0x45, 0x46, 0x08, 0x20, 0x86,
	0x59, 0x0a, 0x4c, 0x4e, 0xd4, 0x00, 0x6d, 0x37, 0x39, 0x7a, 0x08, 0xc5, 0xa5, 0x27, 0xac, 0xc4,
	0xd8, 0x99, 0x2c, 0xd8, 0x8a, 0x8c, 0xee, 0x40, 0x69, 0xc5, 0xba, 0xa1, 0xf9, 0x09, 0x08, 0x7f,
	0xd7, 0xd7, 0xe8, 0x18, 0x60, 0x61, 0x09, 0x4b, 0xdd, 0xfd, 0x70, 0x56, 0xcd, 0xcf, 0x57, 0x28,
	0xb2, 0xf8, 0x18, 0x32, 0x2f, 0xa6, 0xc4, 0xbf, 0x46, 0xc7, 0x50, 0x20, 0x6f, 0x27, 0x3e, 0x09,
	0x02, 0xf6, 0x37, 0x11, 0xbf, 0xa4, 0xc5, 0xe5, 0xcb, 0xf8, 0x76, 0xe2, 0x8b, 0x3f, 0xa4, 0x20,
	0x1d, 0x7d, 0xa0, 0x02, 0xa4, 0x5c, 0x2f, 0xfe, 0xf5, 0xd9, 0x43, 0x65, 0xc8, 0x50, 0xef, 0x0b,
	0xe2, 0xc6, 0xf9, 0x5c, 0x24, 0xd0, 0x31, 0xa4, 0xaf, 0xc6, 0xe6, 0x70, 0xfe, 0x83, 0x73, 0x70,
	0x53, 0xa2, 0x7e, 0x36, 0x36, 0x87, 0xcc, 0x6e, 0x0a, 0xf3, 0x97, 0x8b, 0x9d, 0x7c, 0x7a, 0xfd,
	0x15, 0x60, 0xcc, 0xf8, 0xfd, 0x8a, 0x3c, 0xe6, 0x22, 0x21, 0x8e, 0x21, 0x1d, 0xad, 0x44, 0xb7,
	0xe1, 0x00, 0x7f, 0xde, 0xd5, 0x8c, 0xb3, 0x96, 0x74, 0x6e, 0x28, 0xea, 0xa5, 0xd4, 0x52, 0x64,
	0x3e, 0x81, 0x6e, 0x01, 0xbf, 0x9a, 0xee, 0xab, 0x1a, 0x96, 0x64, 0x9e, 0x43, 0x15, 0x38, 0xda,
	0x9c, 0x35, 0x96, 0x7f, 0x76, 0x7c, 0x12, 0xdd, 0x85, 0x7f, 0xad, 0xf0, 0xb3, 0x4e, 0xab, 0xd5,
	0xf9, 0x4c, 0x51, 0xcf, 0xf9, 0x94, 0xf8, 0x23, 0x07, 0xb0, 0x0a, 0x1f, 0x39, 0x02, 0xe3, 0xe9,
	0x17, 0x4c, 0x22, 0xf6, 0xb8, 0x65, 0xec, 0x5d, 0x68, 0x57, 0xd2, 0x95, 0xc8, 0x2f, 0xb8, 0xc8,
	0x8d, 0xb6, 0x50, 0x1d, 0x4b, 0x6d, 0x3e, 0xb9, 0x73, 0x61, 0xaf, 0xdf, 0xed, 0x76, 0x34, 0x9d,
	0x4f, 0xa1, 0x7b, 0x70, 0x77, 0x1b, 0xc5, 0xcd, 0xbe, 0x86, 0xf9, 0x74, 0xe4, 0x8e, 0xdb, 0xa0,
	0x2e, 0xa9, 0xb2, 0xa4, 0xc9, 0x7c, 0xa6, 0x91, 0x83, 0xcc, 0x6b, 0x73, 0x3c, 0x25, 0x8d, 0x27,
	0xef, 0xde, 0x57, 0x12, 0xbf, 0xbe, 0xaf, 0x24, 0x3e, 0xbc, 0xaf, 0x70, 0x5f, 0x85, 0x15, 0xee,
	0xfb, 0xb0, 0xc2, 0xfd, 0x1c, 0x56, 0xb8, 0x77, 0x61, 0x85, 0xfb, 0x2d, 0xac, 0x70, 0x7f, 0x84,
	0x95, 0xc4, 0x87, 0xb0, 0xc2, 0x7d, 0xf7, 0x7b, 0x25, 0xf1, 0x2a, 0xcb, 0x7e, 0xa7, 0x9f, 0xfd,
	0x15, 0x00, 0x00, 0xff, 0xff, 0xcb, 0x9c, 0xcf, 0xd3, 0x92, 0x0b, 0x00, 0x00,
}
