// Code generated by protoc-gen-gogo.
// source: questions.proto
// DO NOT EDIT!

package intake

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type QuestionData_Type int32

const (
	QuestionData_MULTIPLE_CHOICE QuestionData_Type = 0
	QuestionData_FREE_TEXT       QuestionData_Type = 1
	QuestionData_AUTOCOMPLETE    QuestionData_Type = 2
	QuestionData_MEDIA_SECTION   QuestionData_Type = 3
	QuestionData_SINGLE_ENTRY    QuestionData_Type = 4
)

var QuestionData_Type_name = map[int32]string{
	0: "MULTIPLE_CHOICE",
	1: "FREE_TEXT",
	2: "AUTOCOMPLETE",
	3: "MEDIA_SECTION",
	4: "SINGLE_ENTRY",
}
var QuestionData_Type_value = map[string]int32{
	"MULTIPLE_CHOICE": 0,
	"FREE_TEXT":       1,
	"AUTOCOMPLETE":    2,
	"MEDIA_SECTION":   3,
	"SINGLE_ENTRY":    4,
}

func (x QuestionData_Type) Enum() *QuestionData_Type {
	p := new(QuestionData_Type)
	*p = x
	return p
}
func (x QuestionData_Type) String() string {
	return proto.EnumName(QuestionData_Type_name, int32(x))
}
func (x *QuestionData_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(QuestionData_Type_value, data, "QuestionData_Type")
	if err != nil {
		return err
	}
	*x = QuestionData_Type(value)
	return nil
}

// Config indicates the behavior of the multiple choice question
// to either function as a single select, a segmented control or a
// regular multiple choice question.
type MultipleChoiceQuestion_Config int32

const (
	MultipleChoiceQuestion_SINGLE_SELECT     MultipleChoiceQuestion_Config = 1
	MultipleChoiceQuestion_SEGMENTED_CONTROL MultipleChoiceQuestion_Config = 2
	MultipleChoiceQuestion_MULTIPLE_CHOICE   MultipleChoiceQuestion_Config = 3
)

var MultipleChoiceQuestion_Config_name = map[int32]string{
	1: "SINGLE_SELECT",
	2: "SEGMENTED_CONTROL",
	3: "MULTIPLE_CHOICE",
}
var MultipleChoiceQuestion_Config_value = map[string]int32{
	"SINGLE_SELECT":     1,
	"SEGMENTED_CONTROL": 2,
	"MULTIPLE_CHOICE":   3,
}

func (x MultipleChoiceQuestion_Config) Enum() *MultipleChoiceQuestion_Config {
	p := new(MultipleChoiceQuestion_Config)
	*p = x
	return p
}
func (x MultipleChoiceQuestion_Config) String() string {
	return proto.EnumName(MultipleChoiceQuestion_Config_name, int32(x))
}
func (x *MultipleChoiceQuestion_Config) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MultipleChoiceQuestion_Config_value, data, "MultipleChoiceQuestion_Config")
	if err != nil {
		return err
	}
	*x = MultipleChoiceQuestion_Config(value)
	return nil
}

type MultipleChoiceQuestion_PotentialAnswer_Type int32

const (
	MultipleChoiceQuestion_PotentialAnswer_OPTION            MultipleChoiceQuestion_PotentialAnswer_Type = 0
	MultipleChoiceQuestion_PotentialAnswer_NONE_OF_THE_ABOVE MultipleChoiceQuestion_PotentialAnswer_Type = 1
	MultipleChoiceQuestion_PotentialAnswer_OTHER_FREE_TEXT   MultipleChoiceQuestion_PotentialAnswer_Type = 2
)

var MultipleChoiceQuestion_PotentialAnswer_Type_name = map[int32]string{
	0: "OPTION",
	1: "NONE_OF_THE_ABOVE",
	2: "OTHER_FREE_TEXT",
}
var MultipleChoiceQuestion_PotentialAnswer_Type_value = map[string]int32{
	"OPTION":            0,
	"NONE_OF_THE_ABOVE": 1,
	"OTHER_FREE_TEXT":   2,
}

func (x MultipleChoiceQuestion_PotentialAnswer_Type) Enum() *MultipleChoiceQuestion_PotentialAnswer_Type {
	p := new(MultipleChoiceQuestion_PotentialAnswer_Type)
	*p = x
	return p
}
func (x MultipleChoiceQuestion_PotentialAnswer_Type) String() string {
	return proto.EnumName(MultipleChoiceQuestion_PotentialAnswer_Type_name, int32(x))
}
func (x *MultipleChoiceQuestion_PotentialAnswer_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MultipleChoiceQuestion_PotentialAnswer_Type_value, data, "MultipleChoiceQuestion_PotentialAnswer_Type")
	if err != nil {
		return err
	}
	*x = MultipleChoiceQuestion_PotentialAnswer_Type(value)
	return nil
}

type MediaSectionQuestion_MediaSlot_FlashState int32

const (
	MediaSectionQuestion_MediaSlot_OFF  MediaSectionQuestion_MediaSlot_FlashState = 0
	MediaSectionQuestion_MediaSlot_ON   MediaSectionQuestion_MediaSlot_FlashState = 1
	MediaSectionQuestion_MediaSlot_AUTO MediaSectionQuestion_MediaSlot_FlashState = 2
)

var MediaSectionQuestion_MediaSlot_FlashState_name = map[int32]string{
	0: "OFF",
	1: "ON",
	2: "AUTO",
}
var MediaSectionQuestion_MediaSlot_FlashState_value = map[string]int32{
	"OFF":  0,
	"ON":   1,
	"AUTO": 2,
}

func (x MediaSectionQuestion_MediaSlot_FlashState) Enum() *MediaSectionQuestion_MediaSlot_FlashState {
	p := new(MediaSectionQuestion_MediaSlot_FlashState)
	*p = x
	return p
}
func (x MediaSectionQuestion_MediaSlot_FlashState) String() string {
	return proto.EnumName(MediaSectionQuestion_MediaSlot_FlashState_name, int32(x))
}
func (x *MediaSectionQuestion_MediaSlot_FlashState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MediaSectionQuestion_MediaSlot_FlashState_value, data, "MediaSectionQuestion_MediaSlot_FlashState")
	if err != nil {
		return err
	}
	*x = MediaSectionQuestion_MediaSlot_FlashState(value)
	return nil
}

type MediaSectionQuestion_MediaSlot_TipStyle int32

const (
	MediaSectionQuestion_MediaSlot_DEFAULT     MediaSectionQuestion_MediaSlot_TipStyle = 0
	MediaSectionQuestion_MediaSlot_POINT_LEFT  MediaSectionQuestion_MediaSlot_TipStyle = 1
	MediaSectionQuestion_MediaSlot_POINT_RIGHT MediaSectionQuestion_MediaSlot_TipStyle = 2
)

var MediaSectionQuestion_MediaSlot_TipStyle_name = map[int32]string{
	0: "DEFAULT",
	1: "POINT_LEFT",
	2: "POINT_RIGHT",
}
var MediaSectionQuestion_MediaSlot_TipStyle_value = map[string]int32{
	"DEFAULT":     0,
	"POINT_LEFT":  1,
	"POINT_RIGHT": 2,
}

func (x MediaSectionQuestion_MediaSlot_TipStyle) Enum() *MediaSectionQuestion_MediaSlot_TipStyle {
	p := new(MediaSectionQuestion_MediaSlot_TipStyle)
	*p = x
	return p
}
func (x MediaSectionQuestion_MediaSlot_TipStyle) String() string {
	return proto.EnumName(MediaSectionQuestion_MediaSlot_TipStyle_name, int32(x))
}
func (x *MediaSectionQuestion_MediaSlot_TipStyle) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MediaSectionQuestion_MediaSlot_TipStyle_value, data, "MediaSectionQuestion_MediaSlot_TipStyle")
	if err != nil {
		return err
	}
	*x = MediaSectionQuestion_MediaSlot_TipStyle(value)
	return nil
}

type MediaSectionQuestion_MediaSlot_CameraDirection int32

const (
	MediaSectionQuestion_MediaSlot_FRONT             MediaSectionQuestion_MediaSlot_CameraDirection = 0
	MediaSectionQuestion_MediaSlot_BACK              MediaSectionQuestion_MediaSlot_CameraDirection = 1
	MediaSectionQuestion_MediaSlot_FRONT_OR_PREVIOUS MediaSectionQuestion_MediaSlot_CameraDirection = 2
	MediaSectionQuestion_MediaSlot_BACK_OR_PREVIOUS  MediaSectionQuestion_MediaSlot_CameraDirection = 3
)

var MediaSectionQuestion_MediaSlot_CameraDirection_name = map[int32]string{
	0: "FRONT",
	1: "BACK",
	2: "FRONT_OR_PREVIOUS",
	3: "BACK_OR_PREVIOUS",
}
var MediaSectionQuestion_MediaSlot_CameraDirection_value = map[string]int32{
	"FRONT":             0,
	"BACK":              1,
	"FRONT_OR_PREVIOUS": 2,
	"BACK_OR_PREVIOUS":  3,
}

func (x MediaSectionQuestion_MediaSlot_CameraDirection) Enum() *MediaSectionQuestion_MediaSlot_CameraDirection {
	p := new(MediaSectionQuestion_MediaSlot_CameraDirection)
	*p = x
	return p
}
func (x MediaSectionQuestion_MediaSlot_CameraDirection) String() string {
	return proto.EnumName(MediaSectionQuestion_MediaSlot_CameraDirection_name, int32(x))
}
func (x *MediaSectionQuestion_MediaSlot_CameraDirection) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MediaSectionQuestion_MediaSlot_CameraDirection_value, data, "MediaSectionQuestion_MediaSlot_CameraDirection")
	if err != nil {
		return err
	}
	*x = MediaSectionQuestion_MediaSlot_CameraDirection(value)
	return nil
}

type MediaSectionQuestion_MediaSlot_Type int32

const (
	MediaSectionQuestion_MediaSlot_UNKNOWN MediaSectionQuestion_MediaSlot_Type = 0
	MediaSectionQuestion_MediaSlot_IMAGE   MediaSectionQuestion_MediaSlot_Type = 1
	MediaSectionQuestion_MediaSlot_VIDEO   MediaSectionQuestion_MediaSlot_Type = 2
)

var MediaSectionQuestion_MediaSlot_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "IMAGE",
	2: "VIDEO",
}
var MediaSectionQuestion_MediaSlot_Type_value = map[string]int32{
	"UNKNOWN": 0,
	"IMAGE":   1,
	"VIDEO":   2,
}

func (x MediaSectionQuestion_MediaSlot_Type) Enum() *MediaSectionQuestion_MediaSlot_Type {
	p := new(MediaSectionQuestion_MediaSlot_Type)
	*p = x
	return p
}
func (x MediaSectionQuestion_MediaSlot_Type) String() string {
	return proto.EnumName(MediaSectionQuestion_MediaSlot_Type_name, int32(x))
}
func (x *MediaSectionQuestion_MediaSlot_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MediaSectionQuestion_MediaSlot_Type_value, data, "MediaSectionQuestion_MediaSlot_Type")
	if err != nil {
		return err
	}
	*x = MediaSectionQuestion_MediaSlot_Type(value)
	return nil
}

// QuestionData represents a typed, serialized version of a question. The
// type is used to infer the serialized data in the byte array. This makes it lookup
// the right model to use to deserialize the data into.
type QuestionData struct {
	Type             *QuestionData_Type `protobuf:"varint,1,req,name=type,enum=intake.QuestionData_Type" json:"type,omitempty"`
	Data             []byte             `protobuf:"bytes,2,req,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *QuestionData) Reset()         { *m = QuestionData{} }
func (m *QuestionData) String() string { return proto.CompactTextString(m) }
func (*QuestionData) ProtoMessage()    {}

func (m *QuestionData) GetType() QuestionData_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return QuestionData_MULTIPLE_CHOICE
}

func (m *QuestionData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// ClientAnswerData represents a t  yped, serialized version of the
// answer payload for the client to upload. The goal is for the client
// to treat the payloud as an opaque object that can directly be uploaded
// to the appropriate endpoint.
type ClientAnswerData struct {
	Type             *QuestionData_Type `protobuf:"varint,1,req,name=type,enum=intake.QuestionData_Type" json:"type,omitempty"`
	ClientAnswerJson []byte             `protobuf:"bytes,2,req,name=client_answer_json" json:"client_answer_json,omitempty"`
	QuestionId       *string            `protobuf:"bytes,3,req,name=question_id" json:"question_id,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *ClientAnswerData) Reset()         { *m = ClientAnswerData{} }
func (m *ClientAnswerData) String() string { return proto.CompactTextString(m) }
func (*ClientAnswerData) ProtoMessage()    {}

func (m *ClientAnswerData) GetType() QuestionData_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return QuestionData_MULTIPLE_CHOICE
}

func (m *ClientAnswerData) GetClientAnswerJson() []byte {
	if m != nil {
		return m.ClientAnswerJson
	}
	return nil
}

func (m *ClientAnswerData) GetQuestionId() string {
	if m != nil && m.QuestionId != nil {
		return *m.QuestionId
	}
	return ""
}

// CommonQuestionInfo represents the common data used across all questions.
type CommonQuestionInfo struct {
	// title represents the text pertaining to the question itself.
	Title *string `protobuf:"bytes,1,opt,name=title" json:"title,omitempty"`
	// subtitle is the question subtitle that compliments the title.
	Subtitle *string `protobuf:"bytes,2,opt,name=subtitle" json:"subtitle,omitempty"`
	// id represents the unique identifier for the question.
	Id *string `protobuf:"bytes,3,req,name=id" json:"id,omitempty"`
	// info_popup represents the information to show in a popup if present.
	InfoPopup *InfoPopup `protobuf:"bytes,4,opt,name=info_popup" json:"info_popup,omitempty"`
	// is_required indicates whether or not question is required to have an answer.
	IsRequired       *bool  `protobuf:"varint,5,opt,name=is_required" json:"is_required,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CommonQuestionInfo) Reset()         { *m = CommonQuestionInfo{} }
func (m *CommonQuestionInfo) String() string { return proto.CompactTextString(m) }
func (*CommonQuestionInfo) ProtoMessage()    {}

func (m *CommonQuestionInfo) GetTitle() string {
	if m != nil && m.Title != nil {
		return *m.Title
	}
	return ""
}

func (m *CommonQuestionInfo) GetSubtitle() string {
	if m != nil && m.Subtitle != nil {
		return *m.Subtitle
	}
	return ""
}

func (m *CommonQuestionInfo) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *CommonQuestionInfo) GetInfoPopup() *InfoPopup {
	if m != nil {
		return m.InfoPopup
	}
	return nil
}

func (m *CommonQuestionInfo) GetIsRequired() bool {
	if m != nil && m.IsRequired != nil {
		return *m.IsRequired
	}
	return false
}

// MultipleChoiceQuestion represents the contents of a specific question type
// that contains multiple answer choices from which a patient can select multiple options.
type MultipleChoiceQuestion struct {
	// potential_answers represents the list of potential answers for the multiple choice question.
	PotentialAnswers []*MultipleChoiceQuestion_PotentialAnswer `protobuf:"bytes,1,rep,name=potential_answers" json:"potential_answers,omitempty"`
	QuestionInfo     *CommonQuestionInfo                       `protobuf:"bytes,2,req,name=question_info" json:"question_info,omitempty"`
	// config is used to indicate whether we are working with a regular multiple choice,
	// a segmented control or single select question.
	Config *MultipleChoiceQuestion_Config `protobuf:"varint,3,req,name=config,enum=intake.MultipleChoiceQuestion_Config" json:"config,omitempty"`
	// groups is used to convey groupings for a sectioned multiple choice question.
	Groups []*MultipleChoiceQuestion_TitleCount `protobuf:"bytes,4,rep,name=groups" json:"groups,omitempty"`
	// patient_answer represents the answer by the patient. Given that it can be of type
	// singleSelect, segmentedControl or multipleChoice, sending a typed data representation for the answer
	PatientAnswer    *PatientAnswerData `protobuf:"bytes,5,opt,name=patient_answer" json:"patient_answer,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *MultipleChoiceQuestion) Reset()         { *m = MultipleChoiceQuestion{} }
func (m *MultipleChoiceQuestion) String() string { return proto.CompactTextString(m) }
func (*MultipleChoiceQuestion) ProtoMessage()    {}

func (m *MultipleChoiceQuestion) GetPotentialAnswers() []*MultipleChoiceQuestion_PotentialAnswer {
	if m != nil {
		return m.PotentialAnswers
	}
	return nil
}

func (m *MultipleChoiceQuestion) GetQuestionInfo() *CommonQuestionInfo {
	if m != nil {
		return m.QuestionInfo
	}
	return nil
}

func (m *MultipleChoiceQuestion) GetConfig() MultipleChoiceQuestion_Config {
	if m != nil && m.Config != nil {
		return *m.Config
	}
	return MultipleChoiceQuestion_SINGLE_SELECT
}

func (m *MultipleChoiceQuestion) GetGroups() []*MultipleChoiceQuestion_TitleCount {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *MultipleChoiceQuestion) GetPatientAnswer() *PatientAnswerData {
	if m != nil {
		return m.PatientAnswer
	}
	return nil
}

type MultipleChoiceQuestion_PotentialAnswer struct {
	// text represents the text associated with an answer option.
	Text *string `protobuf:"bytes,1,req,name=text" json:"text,omitempty"`
	// type represents the answer type
	Type *MultipleChoiceQuestion_PotentialAnswer_Type `protobuf:"varint,2,req,name=type,enum=intake.MultipleChoiceQuestion_PotentialAnswer_Type" json:"type,omitempty"`
	// id represents the unique identifier for the answer selection.
	Id *string `protobuf:"bytes,3,req,name=id" json:"id,omitempty"`
	// info_popup represents the information to show in a popup if present.
	InfoPopup *InfoPopup `protobuf:"bytes,4,opt,name=info_popup" json:"info_popup,omitempty"`
	// placeholder_text represents the text to show for other free text type.
	PlaceholderText  *string `protobuf:"bytes,5,opt,name=placeholder_text" json:"placeholder_text,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *MultipleChoiceQuestion_PotentialAnswer) Reset() {
	*m = MultipleChoiceQuestion_PotentialAnswer{}
}
func (m *MultipleChoiceQuestion_PotentialAnswer) String() string { return proto.CompactTextString(m) }
func (*MultipleChoiceQuestion_PotentialAnswer) ProtoMessage()    {}

func (m *MultipleChoiceQuestion_PotentialAnswer) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

func (m *MultipleChoiceQuestion_PotentialAnswer) GetType() MultipleChoiceQuestion_PotentialAnswer_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return MultipleChoiceQuestion_PotentialAnswer_OPTION
}

func (m *MultipleChoiceQuestion_PotentialAnswer) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *MultipleChoiceQuestion_PotentialAnswer) GetInfoPopup() *InfoPopup {
	if m != nil {
		return m.InfoPopup
	}
	return nil
}

func (m *MultipleChoiceQuestion_PotentialAnswer) GetPlaceholderText() string {
	if m != nil && m.PlaceholderText != nil {
		return *m.PlaceholderText
	}
	return ""
}

// TitleCount represents a metadata entry to
// gives a multipled choice question enough information to
// section answer choices together.
type MultipleChoiceQuestion_TitleCount struct {
	Title            *string `protobuf:"bytes,1,req,name=title" json:"title,omitempty"`
	Count            *int32  `protobuf:"varint,2,req,name=count" json:"count,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *MultipleChoiceQuestion_TitleCount) Reset()         { *m = MultipleChoiceQuestion_TitleCount{} }
func (m *MultipleChoiceQuestion_TitleCount) String() string { return proto.CompactTextString(m) }
func (*MultipleChoiceQuestion_TitleCount) ProtoMessage()    {}

func (m *MultipleChoiceQuestion_TitleCount) GetTitle() string {
	if m != nil && m.Title != nil {
		return *m.Title
	}
	return ""
}

func (m *MultipleChoiceQuestion_TitleCount) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

// FreeTextQuestion represents the contents of a specific question type
// that allows a patient to enter a free text response to the question.
type FreeTextQuestion struct {
	// placeholder represents the text to show when the free text box is empty.
	Placeholder      *string                `protobuf:"bytes,1,opt,name=placeholder,def=Type in some text..." json:"placeholder,omitempty"`
	QuestionInfo     *CommonQuestionInfo    `protobuf:"bytes,2,req,name=question_info" json:"question_info,omitempty"`
	PatientAnswer    *FreeTextPatientAnswer `protobuf:"bytes,3,opt,name=patient_answer" json:"patient_answer,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *FreeTextQuestion) Reset()         { *m = FreeTextQuestion{} }
func (m *FreeTextQuestion) String() string { return proto.CompactTextString(m) }
func (*FreeTextQuestion) ProtoMessage()    {}

const Default_FreeTextQuestion_Placeholder string = "Type in some text..."

func (m *FreeTextQuestion) GetPlaceholder() string {
	if m != nil && m.Placeholder != nil {
		return *m.Placeholder
	}
	return Default_FreeTextQuestion_Placeholder
}

func (m *FreeTextQuestion) GetQuestionInfo() *CommonQuestionInfo {
	if m != nil {
		return m.QuestionInfo
	}
	return nil
}

func (m *FreeTextQuestion) GetPatientAnswer() *FreeTextPatientAnswer {
	if m != nil {
		return m.PatientAnswer
	}
	return nil
}

// SingleEntryQuestion represents the contents of a specific question type
// that allows a patient to enter a free text response to the question.
type SingleEntryQuestion struct {
	// placeholder represents the text to show when the free text box is empty.
	Placeholder      *string                   `protobuf:"bytes,1,opt,name=placeholder,def=Type in some text..." json:"placeholder,omitempty"`
	QuestionInfo     *CommonQuestionInfo       `protobuf:"bytes,2,req,name=question_info" json:"question_info,omitempty"`
	PatientAnswer    *SingleEntryPatientAnswer `protobuf:"bytes,3,opt,name=patient_answer" json:"patient_answer,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *SingleEntryQuestion) Reset()         { *m = SingleEntryQuestion{} }
func (m *SingleEntryQuestion) String() string { return proto.CompactTextString(m) }
func (*SingleEntryQuestion) ProtoMessage()    {}

const Default_SingleEntryQuestion_Placeholder string = "Type in some text..."

func (m *SingleEntryQuestion) GetPlaceholder() string {
	if m != nil && m.Placeholder != nil {
		return *m.Placeholder
	}
	return Default_SingleEntryQuestion_Placeholder
}

func (m *SingleEntryQuestion) GetQuestionInfo() *CommonQuestionInfo {
	if m != nil {
		return m.QuestionInfo
	}
	return nil
}

func (m *SingleEntryQuestion) GetPatientAnswer() *SingleEntryPatientAnswer {
	if m != nil {
		return m.PatientAnswer
	}
	return nil
}

// AutocompleteQuestion represents a question where the user can
// add answer choices based on results from an autocomplete API.
type AutocompleteQuestion struct {
	QuestionInfo *CommonQuestionInfo `protobuf:"bytes,1,req,name=question_info" json:"question_info,omitempty"`
	// add_text represents the text to display to prompt the user
	// to add an answer option from the autocomplete API.
	AddText *string `protobuf:"bytes,2,opt,name=add_text" json:"add_text,omitempty"`
	// remove_button_text represents the text to display to indicate removing of
	// an answer that was added.
	RemoveButtonText *string `protobuf:"bytes,3,opt,name=remove_button_text" json:"remove_button_text,omitempty"`
	// add_button_text represents the text to display when there are subquestions
	// for an autocomplete question and the user is attempting to add
	// an answer option with subanswers.
	AddButtonText *string `protobuf:"bytes,4,opt,name=add_button_text" json:"add_button_text,omitempty"`
	// save_button_text represents the text to display when editing the
	// subquestions pertaining to an autocomplete question.
	SaveButtonText *string `protobuf:"bytes,5,opt,name=save_button_text" json:"save_button_text,omitempty"`
	// placeholder_text represents the text to display when the searchbox
	// is empty.
	PlaceholderText *string                    `protobuf:"bytes,6,opt,name=placeholder_text" json:"placeholder_text,omitempty"`
	PatientAnswer   *AutocompletePatientAnswer `protobuf:"bytes,7,opt,name=patient_answer" json:"patient_answer,omitempty"`
	// params are used by client to query autocomplete
	// data from the server
	Params           map[string]string `protobuf:"bytes,8,rep,name=params" json:"params,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *AutocompleteQuestion) Reset()         { *m = AutocompleteQuestion{} }
func (m *AutocompleteQuestion) String() string { return proto.CompactTextString(m) }
func (*AutocompleteQuestion) ProtoMessage()    {}

func (m *AutocompleteQuestion) GetQuestionInfo() *CommonQuestionInfo {
	if m != nil {
		return m.QuestionInfo
	}
	return nil
}

func (m *AutocompleteQuestion) GetAddText() string {
	if m != nil && m.AddText != nil {
		return *m.AddText
	}
	return ""
}

func (m *AutocompleteQuestion) GetRemoveButtonText() string {
	if m != nil && m.RemoveButtonText != nil {
		return *m.RemoveButtonText
	}
	return ""
}

func (m *AutocompleteQuestion) GetAddButtonText() string {
	if m != nil && m.AddButtonText != nil {
		return *m.AddButtonText
	}
	return ""
}

func (m *AutocompleteQuestion) GetSaveButtonText() string {
	if m != nil && m.SaveButtonText != nil {
		return *m.SaveButtonText
	}
	return ""
}

func (m *AutocompleteQuestion) GetPlaceholderText() string {
	if m != nil && m.PlaceholderText != nil {
		return *m.PlaceholderText
	}
	return ""
}

func (m *AutocompleteQuestion) GetPatientAnswer() *AutocompletePatientAnswer {
	if m != nil {
		return m.PatientAnswer
	}
	return nil
}

func (m *AutocompleteQuestion) GetParams() map[string]string {
	if m != nil {
		return m.Params
	}
	return nil
}

// MediaSectionQuestion represents a question for the user
// to enter a variable number of groupings of photos
// into photo slot definitions.
type MediaSectionQuestion struct {
	QuestionInfo *CommonQuestionInfo               `protobuf:"bytes,1,req,name=question_info" json:"question_info,omitempty"`
	MediaSlots   []*MediaSectionQuestion_MediaSlot `protobuf:"bytes,2,rep,name=media_slots" json:"media_slots,omitempty"`
	// allows_multiple_sections indicates whether or not the user is allowed to
	// enter a variable number of sections of photos during intake for this photo
	// section question.
	AllowsMultipleSections *bool `protobuf:"varint,3,opt,name=allows_multiple_sections" json:"allows_multiple_sections,omitempty"`
	// user_defined_section_title indicates whether or not the user is allowed
	// to define the title of the section during photo intake.
	UserDefinedSectionTitle *bool `protobuf:"varint,4,opt,name=user_defined_section_title" json:"user_defined_section_title,omitempty"`
	// disable_last_slot_duplication is a flag that indicates whether to disable or keep enabled
	// duplication of the last photo slot in the photo section question.
	DisableLastSlotDuplication *bool                      `protobuf:"varint,5,opt,name=disable_last_slot_duplication" json:"disable_last_slot_duplication,omitempty"`
	PatientAnswer              *MediaSectionPatientAnswer `protobuf:"bytes,6,opt,name=patient_answer" json:"patient_answer,omitempty"`
	XXX_unrecognized           []byte                     `json:"-"`
}

func (m *MediaSectionQuestion) Reset()         { *m = MediaSectionQuestion{} }
func (m *MediaSectionQuestion) String() string { return proto.CompactTextString(m) }
func (*MediaSectionQuestion) ProtoMessage()    {}

func (m *MediaSectionQuestion) GetQuestionInfo() *CommonQuestionInfo {
	if m != nil {
		return m.QuestionInfo
	}
	return nil
}

func (m *MediaSectionQuestion) GetMediaSlots() []*MediaSectionQuestion_MediaSlot {
	if m != nil {
		return m.MediaSlots
	}
	return nil
}

func (m *MediaSectionQuestion) GetAllowsMultipleSections() bool {
	if m != nil && m.AllowsMultipleSections != nil {
		return *m.AllowsMultipleSections
	}
	return false
}

func (m *MediaSectionQuestion) GetUserDefinedSectionTitle() bool {
	if m != nil && m.UserDefinedSectionTitle != nil {
		return *m.UserDefinedSectionTitle
	}
	return false
}

func (m *MediaSectionQuestion) GetDisableLastSlotDuplication() bool {
	if m != nil && m.DisableLastSlotDuplication != nil {
		return *m.DisableLastSlotDuplication
	}
	return false
}

func (m *MediaSectionQuestion) GetPatientAnswer() *MediaSectionPatientAnswer {
	if m != nil {
		return m.PatientAnswer
	}
	return nil
}

// MediaSlot represents the information pertaining to a photo
// slot that the user is intended to fill.
type MediaSectionQuestion_MediaSlot struct {
	// name of the photo slot to be displayed to the user.
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// is_required indicates whether or not photo_slot is required
	// to be filled by user during photo intake for this question.
	IsRequired *bool `protobuf:"varint,2,opt,name=is_required" json:"is_required,omitempty"`
	// tip is the information to display to the user while or prior to taking
	// a picture for this photo slot.
	Tip *string `protobuf:"bytes,3,opt,name=tip" json:"tip,omitempty"`
	// tip_subtext represents the secondary level of information to display to the user
	// while or prior to taking a picture for this photo slot.
	TipSubtext *string `protobuf:"bytes,4,opt,name=tip_subtext" json:"tip_subtext,omitempty"`
	// tip_style represents the styling information for the tip.
	TipStyle *MediaSectionQuestion_MediaSlot_TipStyle `protobuf:"varint,5,opt,name=tip_style,enum=intake.MediaSectionQuestion_MediaSlot_TipStyle,def=0" json:"tip_style,omitempty"`
	// overlay_image_link represents the image to overlay on the camera view
	// while the user is taking a picture to fill this photo slot.
	OverlayImageLink *string `protobuf:"bytes,6,opt,name=overlay_image_link" json:"overlay_image_link,omitempty"`
	// media_missing_error_msg represents the error to display to the user
	// if the photo is missing for this specific slot.
	MediaMissingErrorMsg *string `protobuf:"bytes,7,opt,name=media_missing_error_msg" json:"media_missing_error_msg,omitempty"`
	// initial_camera_direction represents the direction in which to invoke
	// the camera when the camera view is opened for intake pertaining to this slot.
	InitialCameraDirection *MediaSectionQuestion_MediaSlot_CameraDirection `protobuf:"varint,8,opt,name=initial_camera_direction,enum=intake.MediaSectionQuestion_MediaSlot_CameraDirection,def=0" json:"initial_camera_direction,omitempty"`
	// flash_state represents the initial state of the flash when the
	// camera view is opened for intake pertaining to this slot.
	FlashState *MediaSectionQuestion_MediaSlot_FlashState `protobuf:"varint,9,opt,name=flash_state,enum=intake.MediaSectionQuestion_MediaSlot_FlashState,def=2" json:"flash_state,omitempty"`
	// id represents the unique identifier for the photo slot.
	Id *string `protobuf:"bytes,10,req,name=id" json:"id,omitempty"`
	// type indicates whether the slot holds an image or a video
	Type             *MediaSectionQuestion_MediaSlot_Type `protobuf:"varint,11,req,name=type,enum=intake.MediaSectionQuestion_MediaSlot_Type" json:"type,omitempty"`
	XXX_unrecognized []byte                               `json:"-"`
}

func (m *MediaSectionQuestion_MediaSlot) Reset()         { *m = MediaSectionQuestion_MediaSlot{} }
func (m *MediaSectionQuestion_MediaSlot) String() string { return proto.CompactTextString(m) }
func (*MediaSectionQuestion_MediaSlot) ProtoMessage()    {}

const Default_MediaSectionQuestion_MediaSlot_TipStyle MediaSectionQuestion_MediaSlot_TipStyle = MediaSectionQuestion_MediaSlot_DEFAULT
const Default_MediaSectionQuestion_MediaSlot_InitialCameraDirection MediaSectionQuestion_MediaSlot_CameraDirection = MediaSectionQuestion_MediaSlot_FRONT
const Default_MediaSectionQuestion_MediaSlot_FlashState MediaSectionQuestion_MediaSlot_FlashState = MediaSectionQuestion_MediaSlot_AUTO

func (m *MediaSectionQuestion_MediaSlot) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *MediaSectionQuestion_MediaSlot) GetIsRequired() bool {
	if m != nil && m.IsRequired != nil {
		return *m.IsRequired
	}
	return false
}

func (m *MediaSectionQuestion_MediaSlot) GetTip() string {
	if m != nil && m.Tip != nil {
		return *m.Tip
	}
	return ""
}

func (m *MediaSectionQuestion_MediaSlot) GetTipSubtext() string {
	if m != nil && m.TipSubtext != nil {
		return *m.TipSubtext
	}
	return ""
}

func (m *MediaSectionQuestion_MediaSlot) GetTipStyle() MediaSectionQuestion_MediaSlot_TipStyle {
	if m != nil && m.TipStyle != nil {
		return *m.TipStyle
	}
	return Default_MediaSectionQuestion_MediaSlot_TipStyle
}

func (m *MediaSectionQuestion_MediaSlot) GetOverlayImageLink() string {
	if m != nil && m.OverlayImageLink != nil {
		return *m.OverlayImageLink
	}
	return ""
}

func (m *MediaSectionQuestion_MediaSlot) GetMediaMissingErrorMsg() string {
	if m != nil && m.MediaMissingErrorMsg != nil {
		return *m.MediaMissingErrorMsg
	}
	return ""
}

func (m *MediaSectionQuestion_MediaSlot) GetInitialCameraDirection() MediaSectionQuestion_MediaSlot_CameraDirection {
	if m != nil && m.InitialCameraDirection != nil {
		return *m.InitialCameraDirection
	}
	return Default_MediaSectionQuestion_MediaSlot_InitialCameraDirection
}

func (m *MediaSectionQuestion_MediaSlot) GetFlashState() MediaSectionQuestion_MediaSlot_FlashState {
	if m != nil && m.FlashState != nil {
		return *m.FlashState
	}
	return Default_MediaSectionQuestion_MediaSlot_FlashState
}

func (m *MediaSectionQuestion_MediaSlot) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *MediaSectionQuestion_MediaSlot) GetType() MediaSectionQuestion_MediaSlot_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return MediaSectionQuestion_MediaSlot_UNKNOWN
}

func init() {
	proto.RegisterType((*QuestionData)(nil), "intake.QuestionData")
	proto.RegisterType((*ClientAnswerData)(nil), "intake.ClientAnswerData")
	proto.RegisterType((*CommonQuestionInfo)(nil), "intake.CommonQuestionInfo")
	proto.RegisterType((*MultipleChoiceQuestion)(nil), "intake.MultipleChoiceQuestion")
	proto.RegisterType((*MultipleChoiceQuestion_PotentialAnswer)(nil), "intake.MultipleChoiceQuestion.PotentialAnswer")
	proto.RegisterType((*MultipleChoiceQuestion_TitleCount)(nil), "intake.MultipleChoiceQuestion.TitleCount")
	proto.RegisterType((*FreeTextQuestion)(nil), "intake.FreeTextQuestion")
	proto.RegisterType((*SingleEntryQuestion)(nil), "intake.SingleEntryQuestion")
	proto.RegisterType((*AutocompleteQuestion)(nil), "intake.AutocompleteQuestion")
	proto.RegisterType((*MediaSectionQuestion)(nil), "intake.MediaSectionQuestion")
	proto.RegisterType((*MediaSectionQuestion_MediaSlot)(nil), "intake.MediaSectionQuestion.MediaSlot")
	proto.RegisterEnum("intake.QuestionData_Type", QuestionData_Type_name, QuestionData_Type_value)
	proto.RegisterEnum("intake.MultipleChoiceQuestion_Config", MultipleChoiceQuestion_Config_name, MultipleChoiceQuestion_Config_value)
	proto.RegisterEnum("intake.MultipleChoiceQuestion_PotentialAnswer_Type", MultipleChoiceQuestion_PotentialAnswer_Type_name, MultipleChoiceQuestion_PotentialAnswer_Type_value)
	proto.RegisterEnum("intake.MediaSectionQuestion_MediaSlot_FlashState", MediaSectionQuestion_MediaSlot_FlashState_name, MediaSectionQuestion_MediaSlot_FlashState_value)
	proto.RegisterEnum("intake.MediaSectionQuestion_MediaSlot_TipStyle", MediaSectionQuestion_MediaSlot_TipStyle_name, MediaSectionQuestion_MediaSlot_TipStyle_value)
	proto.RegisterEnum("intake.MediaSectionQuestion_MediaSlot_CameraDirection", MediaSectionQuestion_MediaSlot_CameraDirection_name, MediaSectionQuestion_MediaSlot_CameraDirection_value)
	proto.RegisterEnum("intake.MediaSectionQuestion_MediaSlot_Type", MediaSectionQuestion_MediaSlot_Type_name, MediaSectionQuestion_MediaSlot_Type_value)
}
